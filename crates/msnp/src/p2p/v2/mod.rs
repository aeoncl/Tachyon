pub mod pending_packet;
pub mod opcode;
pub mod p2p_payload;
pub mod p2p_transport_packet;
pub mod slp_payload;
pub mod tlv;
pub mod slp_payload_handler;
pub mod slp_context;
pub mod file;
pub mod events;
pub mod session;
pub mod app_id;
pub mod models;
pub mod error;

pub mod factories {
    use base64::Engine;
    use base64::engine::general_purpose;
    use byteorder::{BigEndian, ByteOrder, LittleEndian};

    use crate::{msnp::error::PayloadError, shared::models::{msn_object::MsnObject, msn_user::MsnUser, uuid::Uuid}};

    use super::{p2p_payload::P2PPayload, p2p_transport_packet::P2PTransportPacket, slp_context::PreviewData, slp_payload::{EufGUID, SlpPayload}, tlv::TLV};

    /**
 * RT5'}L³E[@
ÆhÅ6GÆð;ÐvÖPõ¤£UUN 14 aeontest@escargot.chat;{6c03b198-22eb-49f4-b4d6-8eb5567b2e8c} 3 743
INVITE MSNMSGR:aeontest@escargot.chat;{6c03b198-22eb-49f4-b4d6-8eb5567b2e8c} MSNSLP/1.0
To: <msnmsgr:aeontest@shl.local;{f52973b6-c926-4bad-9ba8-7c1e840e4ab0}>
From: <msnmsgr:aeontest3@shl.local;{77c46a8f-33a3-5282-9a5d-905ecd3eb069}>
Via: MSNSLP/1.0/TLP ;branch={2477EF37-9DC5-4884-BC5E-1D32FE3BEC2F}
CSeq: 0 
Call-ID: {AFDB2A8D-0514-488F-9667-35624900DBE3}
Max-Forwards: 0
Content-Type: application/x-msnmsgr-transreqbody
Content-Length: 283

NetID: 251789322
Conn-Type: Firewall
TCP-Conn-Type: Firewall
UPnPNat: false
ICF: false
IPv6-global: 
Capabilities-Flags: 1
Nat-Trav-Msg-Type: WLX-Nat-Trav-Msg-Direct-Connect-Req
Bridges: TRUDPv1 TCPv1 SBBridge TURNv1
Hashed-Nonce: {D14FBAF3-CA6B-CC91-F93A-E76F24903F60}


 * 
 * 
 */



            /**
             * RT5'}L³EL@
ÆhÅ>G0ÎÞ%ýPúð£{UUN 13 aeonshl@escargot.chat;{6c03b198-22eb-49f4-b4d6-8eb5567b2e8c} 3 729
MSNSLP/1.0 200 OK
To: <msnmsgr:aeontest3@shl.local;{77c46a8f-33a3-5282-9a5d-905ecd3eb069}>
From: <msnmsgr:aeontest@shl.local;{f52973b6-c926-4bad-9ba8-7c1e840e4ab0}>
Via: MSNSLP/1.0/TLP ;branch={2477EF37-9DC5-4884-BC5E-1D32FE3BEC2F}
CSeq: 1 
Call-ID: {AFDB2A8D-0514-488F-9667-35624900DBE3}
Max-Forwards: 0
Content-Type: application/x-msnmsgr-transrespbody
Content-Length: 338

Listening: true
NeedConnectingEndpointInfo: false
Conn-Type: Firewall
TCP-Conn-Type: Firewall
IPv6-global: 
UPnPNat: false
Capabilities-Flags: 1
srddA-lanretnI4vPI: 51.2.0.01
troP-lanretnI4vPI: 40505
Nat-Trav-Msg-Type: WLX-Nat-Trav-Msg-Direct-Connect-Resp
Bridge: TCPv1
Hashed-Nonce: {5ADF1CCD-28B2-0CDA-26E9-CEB6E3EC8044}


             * 
             * 
             */


/*
E ¨@

ÅJÅHf|a7yj)ßPÿg`£¶8¶C97INVITE MSNMSGR:aeontest@escargot.chat;{6c03b198-22eb-49f4-b4d6-8eb5567b2e8c} MSNSLP/1.0
To: <msnmsgr:aeontest@shl.local;{f52973b6-c926-4bad-9ba8-7c1e840e4ab0}>
From: <msnmsgr:aeontest3@shl.local;{77c46a8f-33a3-5282-9a5d-905ecd3eb069}>
Via: MSNSLP/1.0/TLP ;branch={210985C6-A856-402A-A757-2AD20D04B5D6}
CSeq: 0 
Call-ID: {68BC1AE3-7443-431C-AB3D-16781527BDD3}
Max-Forwards: 0
Content-Type: application/x-msnmsgr-sessionreqbody
Content-Length: 15107

EUF-GUID: {5D3E02AB-6190-11D3-BBBB-00C04F795683}
SessionID: 2216804035
AppID: 2
RequestFlags: 16
Context: PgIAAAIAAABVEwAAAAAAAAAAAABkAG8AZwBlAC4AagBwAGcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIlQTkcNChoKAAAAD


*/



             /**
              EÚÝ@

ÅHÅJyj*f|P ¼<ìª$h.MSNSLP/1.0 200 OK
To: <msnmsgr:aeontest3@shl.local;{77c46a8f-33a3-5282-9a5d-905ecd3eb069}>
From: <msnmsgr:aeontest@shl.local;{f52973b6-c926-4bad-9ba8-7c1e840e4ab0}>
Via: MSNSLP/1.0/TLP ;branch={210985C6-A856-402A-A757-2AD20D04B5D6}
CSeq: 1 
Call-ID: {68BC1AE3-7443-431C-AB3D-16781527BDD3}
Max-Forwards: 0
Content-Type: application/x-msnmsgr-sessionreqbody
Content-Length: 26

SessionID: 2216804035

* 


              */

    pub struct SlpPayloadFactory;

    impl SlpPayloadFactory {

        pub fn get_session_bye(sender: &MsnUser, receiver: &MsnUser, call_id: Uuid, session_id: String) -> Result<SlpPayload, PayloadError> {
            let mut out = SlpPayload::new();
            out.first_line = format!("BYE MSNMSGR:{mpop_id} MSNSLP/1.0", mpop_id = receiver.endpoint_id);
            out.add_header(String::from("To"), format!("<msnmsgr:{mpop_id}>", mpop_id = receiver.endpoint_id));
            out.add_header(String::from("From"), format!("<msnmsgr:{mpop_id}>", mpop_id = sender.endpoint_id));
            out.add_header(String::from("Via"), format!("MSNSLP/1.0/TLP ;branch={{{branch_uuid}}}", branch_uuid = Uuid::new().to_string()));
            out.add_header(String::from("CSeq"), String::from("0"));
            out.add_header(String::from("Call-ID"), format!("{{{call_id}}}", call_id = call_id.to_string()));
            out.add_header(String::from("Max-Forwards"), String::from("0"));
            out.add_header(String::from("Content-Type"), String::from("application/x-msnmsgr-sessionclosebody"));
            out.add_body_property(String::from("SessionID"), session_id);
            return Ok(out);
        }

        pub fn get_200_ok_session(invite: &SlpPayload) -> Result<SlpPayload, PayloadError>  {
            let mut out = SlpPayload::new();
            out.first_line = String::from("MSNSLP/1.0 200 OK");
            out.add_header(String::from("To"), invite.get_header(&String::from("From"))
                .ok_or(PayloadError::MandatoryPartNotFound {name: String::from("From"), payload: format!("{:?}", &invite) })?
                .to_owned());

            out.add_header(String::from("From"), invite.get_header(&String::from("To"))
                .ok_or(PayloadError::MandatoryPartNotFound {name: String::from("To"), payload: format!("{:?}", &invite) })?
                .to_owned());

            out.add_header(String::from("Via"), invite.get_header(&String::from("Via"))
                .ok_or(PayloadError::MandatoryPartNotFound {name: String::from("Via"), payload: format!("{:?}", &invite) })?
                .to_owned());

            let cseq = invite.headers.get("CSeq")
                .ok_or(PayloadError::MandatoryPartNotFound {name: String::from("CSeq"), payload: format!("{:?}", &invite) })?
                .parse::<i32>()? + 1;

            out.add_header(String::from("CSeq"), cseq.to_string());

            out.add_header(String::from("Call-ID"), invite.get_header(&String::from("Call-ID"))
                .ok_or(PayloadError::MandatoryPartNotFound {name: String::from("Call-ID"), payload: format!("{:?}", &invite) })?
                .to_owned());

            out.add_header(String::from("Max-Forwards"), String::from("0"));
            out.add_header(String::from("Content-Type"), String::from("application/x-msnmsgr-sessionreqbody"));

            out.add_body_property(String::from("SessionID"), invite.get_body_property(&String::from("SessionID"))
                .ok_or(PayloadError::MandatoryPartNotFound {name: String::from("SessionID"), payload: format!("{:?}", &invite) })?
                .to_owned());

            return Ok(out);
        }

        pub fn get_file_transfer_request(sender: &MsnUser, receiver: &MsnUser, context: &PreviewData, session_id: u32) -> Result<SlpPayload, PayloadError> {
            let mut out = SlpPayload::new();
            out.first_line = format!("INVITE MSNMSGR:{} MSNSLP/1.0", receiver.endpoint_id);
            out.add_header(String::from("To"), format!("<msnmsgr:{mpop_id}>", mpop_id = receiver.endpoint_id));
            out.add_header(String::from("From"), format!("<msnmsgr:{mpop_id}>", mpop_id = sender.endpoint_id));
            out.add_header(String::from("Via"), format!("MSNSLP/1.0/TLP ;branch={{{branch_uuid}}}", branch_uuid = Uuid::new().to_string()));

            out.add_header(String::from("CSeq"), String::from("0"));
            out.add_header(String::from("Call-ID"), format!("{{{call_id}}}", call_id = Uuid::new().to_string()));
            out.add_header(String::from("Max-Forwards"), String::from("0"));
            out.add_header(String::from("Content-Type"), String::from("application/x-msnmsgr-sessionreqbody"));

            out.add_body_property(String::from("EUF-GUID"), EufGUID::FileTransfer.to_string());
            out.add_body_property(String::from("SessionID"), session_id.to_string());
            out.add_body_property(String::from("AppID"), String::from("2"));
            out.add_body_property(String::from("RequestFlags"), String::from("16"));

            out.add_body_property(String::from("Context"), context.to_string());

            return Ok(out);
        }

        pub fn get_msn_object_request(sender: &MsnUser, receiver: &MsnUser, context: &MsnObject, session_id: u32) -> Result<SlpPayload, PayloadError> {


            let context_b64 = general_purpose::STANDARD.encode(context.to_string_not_encoded());

            let mut out = SlpPayload::new();
            out.first_line = format!("INVITE MSNMSGR:{} MSNSLP/1.0", receiver.endpoint_id);
            out.add_header(String::from("To"), format!("<msnmsgr:{mpop_id}>", mpop_id = receiver.endpoint_id));
            out.add_header(String::from("From"), format!("<msnmsgr:{mpop_id}>", mpop_id = sender.endpoint_id));
            out.add_header(String::from("Via"), format!("MSNSLP/1.0/TLP ;branch={{{branch_uuid}}}", branch_uuid = Uuid::new().to_string()));

            out.add_header(String::from("CSeq"), String::from("0"));
            out.add_header(String::from("Call-ID"), format!("{{{call_id}}}", call_id = Uuid::new().to_string()));
            out.add_header(String::from("Max-Forwards"), String::from("0"));
            out.add_header(String::from("Content-Type"), String::from("application/x-msnmsgr-sessionreqbody"));

            out.add_body_property(String::from("EUF-GUID"), EufGUID::MSNObject.to_string());
            out.add_body_property(String::from("SessionID"), session_id.to_string());
            out.add_body_property(String::from("AppID"), String::from("20"));
            out.add_body_property(String::from("RequestFlags"), String::from("18"));
            out.add_body_property(String::from("Context"), context_b64);
            return Ok(out);
        }

        pub fn get_200_ok_indirect_connect(invite: &SlpPayload) -> Result<SlpPayload, PayloadError> {
            let mut out = SlpPayloadFactory::get_200_ok_direct_connect(invite)?;
            out.add_body_property(String::from("Bridge"), String::from("SBBridge"));
            return Ok(out);
        }

        pub fn get_200_ok_direct_connect(invite: &SlpPayload) -> Result<SlpPayload, PayloadError> {
            let mut out = SlpPayload::new();
            out.first_line = String::from("MSNSLP/1.0 200 OK");

            
            out.add_header(String::from("To"), invite.get_header(&String::from("From"))
                .ok_or(PayloadError::MandatoryPartNotFound {name: String::from("From"), payload: format!("{:?}", &invite) })?
                .to_owned());


            out.add_header(String::from("From"), invite.get_header(&String::from("To"))
                .ok_or(PayloadError::MandatoryPartNotFound {name: String::from("To"), payload: format!("{:?}", &invite) })?
                .to_owned());

            out.add_header(String::from("Via"), invite.get_header(&String::from("Via"))
                .ok_or(PayloadError::MandatoryPartNotFound {name: String::from("Via"), payload: format!("{:?}", &invite) })?
                .to_owned());

            let cseq = invite.headers.get("CSeq")
                .ok_or(PayloadError::MandatoryPartNotFound {name: String::from("CSeq"), payload: format!("{:?}", &invite) })?
                .parse::<i32>()? + 1;

            out.add_header(String::from("CSeq"), cseq.to_string());

            out.add_header(String::from("Call-ID"), invite.get_header(&String::from("Call-ID"))
                .ok_or(PayloadError::MandatoryPartNotFound {name: String::from("Call-ID"), payload: format!("{:?}", &invite) })?
                .to_owned());

            out.add_header(String::from("Max-Forwards"), String::from("0"));
            out.add_header(String::from("Content-Type"), String::from("application/x-msnmsgr-transrespbody"));

            if let Some(session_id) = invite.get_body_property(&String::from("SessionID")){
                out.add_body_property(String::from("SessionID"), session_id.to_owned());
            }

            out.add_body_property(String::from("Listening"), String::from("true"));
            out.add_body_property(String::from("NeedConnectingEndpointInfo"), String::from("false"));
            out.add_body_property(String::from("Conn-Type"), String::from("DirectConnect"));
            out.add_body_property(String::from("TCP-Conn-Type"), String::from("DirectConnect"));
            out.add_body_property(String::from("IPv6-global"), String::from(""));
            out.add_body_property(String::from("UPnPNat"), String::from("false"));
            out.add_body_property(String::from("Capabilities-Flags"), String::from("1"));
            out.add_body_property(String::from("IPv4Internal-Addrs"), String::from("127.0.0.1"));
            out.add_body_property(String::from("IPv4Internal-Port"), String::from("1865"));
            out.add_body_property(String::from("Nat-Trav-Msg-Type"), String::from("WLX-Nat-Trav-Msg-Direct-Connect-Resp"));
            out.add_body_property(String::from("Bridge"), String::from("TCPv1"));
            out.add_body_property(String::from("Hashed-Nonce"), String::from("{2B95F56D-9CA0-9A64-82CE-ADC1F3C55845}"));
            return Ok(out);
        }

        pub fn get_200_ok_direct_connect_bad_port(invite: &SlpPayload) -> Result<SlpPayload, PayloadError> {
            let mut out = SlpPayload::new();
            out.first_line = String::from("MSNSLP/1.0 200 OK");

            
            out.add_header(String::from("To"), invite.get_header(&String::from("From"))
                .ok_or(PayloadError::MandatoryPartNotFound {name: String::from("From"), payload: format!("{:?}", &invite) })?
                .to_owned());


            out.add_header(String::from("From"), invite.get_header(&String::from("To"))
                .ok_or(PayloadError::MandatoryPartNotFound {name: String::from("To"), payload: format!("{:?}", &invite) })?
                .to_owned());

            out.add_header(String::from("Via"), invite.get_header(&String::from("Via"))
                .ok_or(PayloadError::MandatoryPartNotFound {name: String::from("Via"), payload: format!("{:?}", &invite) })?
                .to_owned());

            let cseq = invite.headers.get("CSeq")
                .ok_or(PayloadError::MandatoryPartNotFound {name: String::from("CSeq"), payload: format!("{:?}", &invite) })?
                .parse::<i32>()? + 1;
            out.add_header(String::from("CSeq"), cseq.to_string());

            out.add_header(String::from("Call-ID"), invite.get_header(&String::from("Call-ID"))
                .ok_or(PayloadError::MandatoryPartNotFound {name: String::from("Call-ID"), payload: format!("{:?}", &invite) })?
                .to_owned());

            out.add_header(String::from("Max-Forwards"), String::from("0"));
            out.add_header(String::from("Content-Type"), String::from("application/x-msnmsgr-transrespbody"));

            if let Some(session_id) = invite.get_body_property(&String::from("SessionID")){
                out.add_body_property(String::from("SessionID"), session_id.to_owned());
            }

            out.add_body_property(String::from("Listening"), String::from("true"));
            out.add_body_property(String::from("NeedConnectingEndpointInfo"), String::from("false"));
            out.add_body_property(String::from("Conn-Type"), String::from("Firewall"));
            out.add_body_property(String::from("TCP-Conn-Type"), String::from("Firewall"));
            out.add_body_property(String::from("IPv6-global"), String::from(""));
            out.add_body_property(String::from("UPnPNat"), String::from("false"));
            out.add_body_property(String::from("Capabilities-Flags"), String::from("1"));
            out.add_body_property(String::from("IPv4External-Addrs"), String::from("127.0.0.1"));
            out.add_body_property(String::from("IPv4External-Port"), String::from("1866"));
            out.add_body_property(String::from("Nat-Trav-Msg-Type"), String::from("WLX-Nat-Trav-Msg-Direct-Connect-Resp"));
            out.add_body_property(String::from("Bridge"), String::from("TCPv1"));
            out.add_body_property(String::from("Hashed-Nonce"), String::from("{2B95F56D-9CA0-9A64-82CE-ADC1F3C55845}"));
            return Ok(out);
        }

        pub fn get_500_error_direct_connect(invite: &SlpPayload, bridge: String) -> Result<SlpPayload, PayloadError> {
            let mut out = SlpPayload::new();
            out.first_line = String::from("MSNSLP/1.0 500 Internal Error");

            
            out.add_header(String::from("To"), invite.get_header(&String::from("From"))
                .ok_or(PayloadError::MandatoryPartNotFound {name: String::from("From"), payload: format!("{:?}", &invite) })?
                .to_owned());

            out.add_header(String::from("From"), invite.get_header(&String::from("To"))
                .ok_or(PayloadError::MandatoryPartNotFound {name: String::from("To"), payload: format!("{:?}", &invite) })?
                .to_owned());

            out.add_header(String::from("Via"), invite.get_header(&String::from("Via"))
                .ok_or(PayloadError::MandatoryPartNotFound {name: String::from("Via"), payload: format!("{:?}", &invite) })?
                .to_owned());

            let cseq = invite.headers.get("CSeq")
                .ok_or(PayloadError::MandatoryPartNotFound {name: String::from("CSeq"), payload: format!("{:?}", &invite) })?
                .parse::<i32>()? + 1;

            out.add_header(String::from("CSeq"), cseq.to_string());
            out.add_header(String::from("Call-ID"), invite.get_header(&String::from("Call-ID"))
                .ok_or(PayloadError::MandatoryPartNotFound {name: String::from("Call-ID"), payload: format!("{:?}", &invite) })?
                .to_owned());

            out.add_header(String::from("Max-Forwards"), String::from("0"));
            out.add_header(String::from("Content-Type"), String::from("application/x-msnmsgr-transrespbody"));

            out.add_body_property(String::from("Bridge"), String::from(bridge));
            out.add_body_property(String::from("Nonce"), String::from("{00000000-0000-0000-0000-000000000000}"));
            out.add_body_property(String::from("Capabilities-Flags"), String::from("0"));


            return Ok(out);
        }

        pub fn get_transport_request(sender: &MsnUser, receiver: &MsnUser) -> SlpPayload {
            let mut out = SlpPayload::new();

            out.first_line = format!("INVITE MSNMSGR:{mpop_id} MSNSLP/1.0", mpop_id = &receiver.endpoint_id);

            out.add_header(String::from("To"), format!("<msnmsgr:{mpop_id}>", mpop_id = &receiver.endpoint_id));
            out.add_header(String::from("From"), format!("<msnmsgr:{mpop_id}>", mpop_id = &sender.endpoint_id));
            out.add_header(String::from("Via"), format!("MSNSLP/1.0/TLP ;branch={{{branch_uuid}}}", branch_uuid = Uuid::new().to_string()));

            out.add_header(String::from("CSeq"), String::from("0"));
            out.add_header(String::from("Call-ID"), format!("{{{call_id}}}", call_id = Uuid::new().to_string()));
            out.add_header(String::from("Max-Forwards"), String::from("0"));
            out.add_header(String::from("Content-Type"), String::from("application/x-msnmsgr-transreqbody"));


            out.add_body_property(String::from("NetID"), String::from("251789322"));
            out.add_body_property(String::from("Conn-Type"), String::from("Firewall"));
            out.add_body_property(String::from("TCP-Conn-Type"), String::from("Firewall"));
            out.add_body_property(String::from("UPnPNat"), String::from("false"));
            out.add_body_property(String::from("ICF"), String::from("false"));
            out.add_body_property(String::from("IPv4Internal-Addrs"), String::from("127.0.0.1"));
            out.add_body_property(String::from("IPv4Internal-Port"), String::from("1865"));
            out.add_body_property(String::from("IPv6-global"), String::from(""));
            out.add_body_property(String::from("Capabilities-Flags"), String::from("1"));
            out.add_body_property(String::from("Nat-Trav-Msg-Type"), String::from("WLX-Nat-Trav-Msg-Direct-Connect-Req"));
            out.add_body_property(String::from("Bridges"), String::from("SBBridge"));
            out.add_body_property(String::from("Hashed-Nonce"), String::from("{D14FBAF3-CA6B-CC91-F93A-E76F24903F60}"));

            return out;
        }
    

    }

    pub struct P2PTransportPacketFactory;

    impl P2PTransportPacketFactory {

        pub fn get_ack(next_ack_sequence_number: u32) -> P2PTransportPacket {
            let mut out = P2PTransportPacket::new(0, None);
            out.set_ack(next_ack_sequence_number);
            return out;
        }

        pub fn get_syn_ack(next_ack_sequence_number: u32) -> P2PTransportPacket {
            let mut out = P2PTransportPacketFactory::get_ack(next_ack_sequence_number);
            out.set_syn(TLVFactory::get_client_peer_info());
            out.set_rak();
            return out;
        }

        pub fn get_rak() -> P2PTransportPacket {
            let mut out = P2PTransportPacket::new(0, None);
            out.set_rak();
            return out;
        }
    }


    pub struct P2PPayloadFactory;

    impl P2PPayloadFactory {
        pub fn get_sip_text_message() -> P2PPayload {
            return P2PPayload::new(0x01, 0x0);
        }

        pub fn get_file_transfer(session_id: u32) -> P2PPayload {
            return P2PPayload::new(0x07, session_id);
        }

        pub fn get_data_preparation_message(session_id: u32) -> P2PPayload {
            let mut payload = P2PPayload::new(0x01, session_id);
            payload.set_payload([0x0, 0x0, 0x0, 0x0].to_vec());
            return payload;
        }

        pub fn get_msn_obj(session_id: u32) -> P2PPayload {
            return P2PPayload::new(0x05, session_id);

        }
    }

    pub struct TLVFactory;

    impl TLVFactory {

        pub fn get_ack(sequence_number: u32) -> TLV {
            let mut buffer: [u8;4] = [0,0,0,0];
            BigEndian::write_u32(&mut buffer, sequence_number);
            return TLV::new(0x02, 0x04, buffer.to_vec());
        }

        pub fn get_nak(sequence_number: u32) -> TLV {
            let mut buffer: [u8;4] = [0,0,0,0];
            BigEndian::write_u32(&mut buffer, sequence_number);
            return TLV::new(0x03, 0x04, buffer.to_vec());
        }

        pub fn get_untransfered_data_size(untransfered_payload_data_size: u64) -> TLV {
            let mut buffer: [u8;8] = [0,0,0,0,0,0,0,0];
            BigEndian::write_u64(&mut buffer, untransfered_payload_data_size);
            return TLV::new(0x01, 0x08, buffer.to_vec());
        }

        pub fn get_client_peer_info() -> TLV {

            let protocol_version: u16 = 0x0200;
            let impl_idu: u16 = 0x0000;
            let version: u16 = 0x0e00;

            let reserved_bytes: u16 = 0x2d76;
                                  //0b0000000100001111
            let capabilities: u32 = 0b0000000100001110;

            let mut value: Vec<u8> = Vec::new();

            let mut buffer: [u8;2] = [0,0];
            LittleEndian::write_u16(&mut buffer, protocol_version);
            value.append(&mut buffer.to_vec());

            let mut buffer: [u8;2] = [0,0];
            LittleEndian::write_u16(&mut buffer, impl_idu);
            value.append(&mut buffer.to_vec());
            
            let mut buffer: [u8;2] = [0,0];
            LittleEndian::write_u16(&mut buffer, version);
            value.append(&mut buffer.to_vec());

            let mut buffer: [u8;2] = [0,0];
            LittleEndian::write_u16(&mut buffer, reserved_bytes);
            value.append(&mut buffer.to_vec());

            let mut buffer: [u8;4] = [0,0,0,0];
            LittleEndian::write_u32(&mut buffer, capabilities);
            value.append(&mut buffer.to_vec());            

            return TLV::new(0x01, 0xc, value);
        }


    }

}



#[cfg(test)]
mod tests {
    use crate::shared::payload::msg::raw_msg_payload::RawMsgPayload;

    /*
        #[test]
        #[allow(rustc::invalid_from_utf8_unchecked)]
        fn test_deserialize_msg_command_containing_slp_payload() {

            //let msg : [u8;672] = [0x18, 0x03, 0x02, 0xe2, 0x6a, 0x23, 0x43, 0xff, 0x01, 0x0c, 0x00 ,0x02, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x0f, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08 ,0x00, 0x00, 0x00, 0x00, 0x00, 0x49, 0x4e, 0x56, 0x49, 0x54, 0x45, 0x20, 0x4d, 0x53 ,0x53, 0x47, 0x52, 0x3a, 0x77, 0x70, 0x30, 0x31, 0x40, 0x6c, 0x69, 0x76, 0x65, 0x2e ,0x3b, 0x7b, 0x64, 0x39, 0x66, 0x64, 0x31, 0x36, 0x31, 0x62, 0x2d, 0x64, 0x34, 0x64 ,0x34, 0x63, 0x61, 0x37, 0x2d, 0x38, 0x61, 0x36, 0x38, 0x2d, 0x63, 0x37, 0x30, 0x66 ,0x33, 0x39, 0x61, 0x33, 0x33, 0x30, 0x7d, 0x20, 0x4d, 0x53, 0x4e, 0x53, 0x4c, 0x50 ,0x2e, 0x30, 0x0d, 0x0a, 0x54, 0x6f, 0x3a, 0x20, 0x3c, 0x6d, 0x73, 0x6e, 0x6d, 0x73 ,0x3a, 0x77, 0x70, 0x30, 0x31, 0x40, 0x6c, 0x69, 0x76, 0x65, 0x2e, 0x63, 0x6e, 0x3b ,0x39, 0x66, 0x64, 0x31, 0x36, 0x31, 0x62, 0x2d, 0x64, 0x34, 0x64, 0x38, 0x2d, 0x34 ,0x37, 0x2d, 0x38, 0x61, 0x36, 0x38, 0x2d, 0x63, 0x37, 0x30, 0x66, 0x65, 0x62, 0x33 ,0x33, 0x33, 0x30, 0x7d, 0x3e, 0x0d, 0x0a, 0x46, 0x72, 0x6f, 0x6d, 0x3a, 0x20, 0x3c ,0x6e, 0x6d, 0x73, 0x67, 0x72, 0x3a, 0x66, 0x72, 0x65, 0x65, 0x7a, 0x69, 0x6e, 0x67 ,0x66, 0x74, 0x40, 0x68, 0x6f, 0x74, 0x6d, 0x61, 0x69, 0x6c, 0x2e, 0x63, 0x6f, 0x6d ,0x37, 0x65, 0x64, 0x66, 0x39, 0x64, 0x32, 0x34, 0x2d, 0x37, 0x65, 0x39, 0x38, 0x2d ,0x32, 0x30, 0x2d, 0x39, 0x66, 0x30, 0x35, 0x2d, 0x37, 0x34, 0x63, 0x33, 0x61, 0x62 ,0x30, 0x37, 0x37, 0x30, 0x7d, 0x3e, 0x0d, 0x0a, 0x56, 0x69, 0x61, 0x3a, 0x20, 0x4d ,0x53, 0x4c, 0x50, 0x2f, 0x31, 0x2e, 0x30, 0x2f, 0x54, 0x4c, 0x50, 0x20, 0x3b, 0x62 ,0x6e, 0x63, 0x68, 0x3d, 0x7b, 0x37, 0x42, 0x41, 0x44, 0x41, 0x35, 0x35, 0x39, 0x2d ,0x45, 0x32, 0x2d, 0x34, 0x41, 0x46, 0x45, 0x2d, 0x41, 0x35, 0x32, 0x39, 0x2d, 0x39 ,0x34, 0x41, 0x39, 0x36, 0x34, 0x37, 0x46, 0x44, 0x35, 0x7d, 0x0d, 0x0a, 0x43, 0x53 ,0x3a, 0x20, 0x30, 0x20, 0x0d, 0x0a, 0x43, 0x61, 0x6c, 0x6c, 0x2d, 0x49, 0x44, 0x3a ,0x42, 0x30, 0x42, 0x34, 0x31, 0x41, 0x30, 0x41, 0x2d, 0x35, 0x32, 0x35, 0x32, 0x2d ,0x43, 0x44, 0x2d, 0x42, 0x46, 0x38, 0x31, 0x2d, 0x30, 0x39, 0x36, 0x37, 0x45, 0x39 ,0x38, 0x36, 0x34, 0x34, 0x7d, 0x0d, 0x0a, 0x4d, 0x61, 0x78, 0x2d, 0x46, 0x6f, 0x72 ,0x72, 0x64, 0x73, 0x3a, 0x20, 0x30, 0x0d, 0x0a, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e ,0x54, 0x79, 0x70, 0x65, 0x3a, 0x20, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74 ,0x6e, 0x2f, 0x78, 0x2d, 0x6d, 0x73, 0x6e, 0x6d, 0x73, 0x67, 0x72, 0x2d, 0x73, 0x65 ,0x69, 0x6f, 0x6e, 0x72, 0x65, 0x71, 0x62, 0x6f, 0x64, 0x79, 0x0d, 0x0a, 0x43, 0x6f ,0x65, 0x6e, 0x74, 0x2d, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x3a, 0x20, 0x32, 0x38 ,0x0a, 0x0d, 0x0a, 0x45, 0x55, 0x46, 0x2d, 0x47, 0x55, 0x49, 0x44, 0x3a, 0x20, 0x7b ,0x32, 0x36, 0x38, 0x45, 0x45, 0x43, 0x2d, 0x46, 0x45, 0x43, 0x35, 0x2d, 0x34, 0x39 ,0x2d, 0x39, 0x35, 0x43, 0x33, 0x2d, 0x46, 0x31, 0x32, 0x36, 0x36, 0x39, 0x36, 0x42 ,0x46, 0x36, 0x7d, 0x0d, 0x0a, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x49, 0x44 ,0x32, 0x36, 0x32, 0x35, 0x33, 0x32, 0x39, 0x32, 0x34, 0x37, 0x0d, 0x0a, 0x41, 0x70 ,0x44, 0x3a, 0x20, 0x31, 0x32, 0x0d, 0x0a, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74 ,0x61, 0x67, 0x73, 0x3a, 0x20, 0x31, 0x38, 0x0d, 0x0a, 0x43, 0x6f, 0x6e, 0x74, 0x65 ,0x3a, 0x20, 0x50, 0x47, 0x31, 0x7a, 0x62, 0x6d, 0x39, 0x69, 0x61, 0x69, 0x42, 0x44 ,0x56, 0x68, 0x64, 0x47, 0x39, 0x79, 0x50, 0x53, 0x4a, 0x33, 0x63, 0x44, 0x41, 0x78 ,0x78, 0x70, 0x64, 0x6d, 0x55, 0x75, 0x59, 0x32, 0x34, 0x69, 0x49, 0x46, 0x52, 0x35 ,0x55, 0x39, 0x49, 0x6a, 0x4d, 0x69, 0x49, 0x46, 0x4e, 0x49, 0x51, 0x54, 0x46, 0x45 ,0x4a, 0x5a, 0x54, 0x69, 0x74, 0x72, 0x4e, 0x48, 0x70, 0x4c, 0x4b, 0x30, 0x6c, 0x6d ,0x64, 0x30, 0x52, 0x31, 0x68, 0x79, 0x54, 0x48, 0x49, 0x78, 0x64, 0x56, 0x4e, 0x61 ,0x6c, 0x5a, 0x52, 0x47, 0x73, 0x39, 0x49, 0x69, 0x42, 0x54, 0x61, 0x58, 0x70, 0x6c ,0x49, 0x78, 0x4e, 0x7a, 0x41, 0x35, 0x4e, 0x53, 0x49, 0x67, 0x54, 0x47, 0x39, 0x6a ,0x52, 0x70, 0x62, 0x32, 0x34, 0x39, 0x49, 0x6a, 0x41, 0x69, 0x49, 0x45, 0x5a, 0x79 ,0x56, 0x75, 0x5a, 0x47, 0x78, 0x35, 0x50, 0x53, 0x4a, 0x4e, 0x55, 0x55, 0x46, 0x42 ,0x45, 0x39, 0x50, 0x53, 0x49, 0x76, 0x50, 0x67, 0x41, 0x3d, 0x0d, 0x0a, 0x0d, 0x0a ,0x00, 0x00, 0x00];
            //let msg_command : [u8;626] = [0x4d, 0x53, 0x47, 0x20, 0x38, 0x35, 0x20, 0x44, 0x20, 0x36, 0x31, 0x34, 0x0d, 0x0a, 0x4d, 0x49, 0x4d, 0x45, 0x2d, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x3a, 0x20, 0x31, 0x2e, 0x30, 0x0d, 0x0a, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x54, 0x79, 0x70, 0x65, 0x3a, 0x20, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x78, 0x2d, 0x6d, 0x73, 0x6e, 0x6d, 0x73, 0x67, 0x72, 0x70, 0x32, 0x70, 0x0d, 0x0a, 0x50, 0x32, 0x50, 0x2d, 0x44, 0x65, 0x73, 0x74, 0x3a, 0x20, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x33, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x0d, 0x0a, 0x50, 0x32, 0x50, 0x2d, 0x53, 0x72, 0x63, 0x3a, 0x20, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x00, 0x00, 0x00, 0xe3, 0xff, 0x3b, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb9, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb9, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xca, 0x3d, 0x5b, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49, 0x4e, 0x56, 0x49, 0x54, 0x45, 0x20, 0x4d, 0x53, 0x4e, 0x4d, 0x53, 0x47, 0x52, 0x3a, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x33, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x4d, 0x53, 0x4e, 0x53, 0x4c, 0x50, 0x2f, 0x31, 0x2e, 0x30, 0x0d, 0x0a, 0x54, 0x6f, 0x3a, 0x20, 0x3c, 0x6d, 0x73, 0x6e, 0x6d, 0x73, 0x67, 0x72, 0x3a, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x33, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x3e, 0x0d, 0x0a, 0x46, 0x72, 0x6f, 0x6d, 0x3a, 0x20, 0x3c, 0x6d, 0x73, 0x6e, 0x6d, 0x73, 0x67, 0x72, 0x3a, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x3e, 0x0d, 0x0a, 0x56, 0x69, 0x61, 0x3a, 0x20, 0x4d, 0x53, 0x4e, 0x53, 0x4c, 0x50, 0x2f, 0x31, 0x2e, 0x30, 0x2f, 0x54, 0x4c, 0x50, 0x20, 0x3b, 0x62, 0x72, 0x61, 0x6e, 0x63, 0x68, 0x3d, 0x7b, 0x43, 0x43, 0x37, 0x42, 0x30, 0x32, 0x46, 0x42, 0x2d, 0x39, 0x30, 0x46, 0x46, 0x2d, 0x34, 0x45, 0x42, 0x39, 0x2d, 0x42, 0x43, 0x37, 0x33, 0x2d, 0x38, 0x41, 0x45, 0x39, 0x34, 0x32, 0x42, 0x31, 0x38, 0x42, 0x41, 0x31, 0x7d, 0x0d, 0x0a, 0x43, 0x53, 0x65, 0x71, 0x3a, 0x20, 0x30, 0x20, 0x0d, 0x0a, 0x43, 0x61, 0x6c, 0x6c, 0x2d, 0x49, 0x44, 0x3a, 0x20, 0x7b, 0x43, 0x36, 0x38, 0x38, 0x43, 0x38, 0x41, 0x42, 0x2d, 0x44, 0x42, 0x38, 0x36, 0x2d, 0x34, 0x34, 0x34, 0x31, 0x2d, 0x38, 0x41, 0x45, 0x33, 0x2d, 0x41, 0x32, 0x43, 0x31, 0x35, 0x42, 0x45, 0x43, 0x30, 0x30, 0x32, 0x37, 0x7d, 0x0d, 0x0a, 0x4d, 0x61, 0x78, 0x2d, 0x46, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x73, 0x3a, 0x20, 0x30, 0x0d, 0x0a, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x54, 0x79, 0x70, 0x65, 0x3a, 0x20, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x78, 0x2d, 0x6d, 0x73, 0x6e, 0x6d, 0x73, 0x67, 0x72, 0x2d, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x72, 0x65, 0x71, 0x62, 0x6f, 0x64, 0x79, 0x0d, 0x0a, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x3a, 0x20, 0x31, 0x30, 0x34, 0x0d, 0x0a, 0x0d, 0x0a, 0x45, 0x55, 0x46, 0x2d, 0x47, 0x55, 0x49, 0x44, 0x3a, 0x20, 0x7b, 0x34, 0x31, 0x44, 0x33, 0x45, 0x37, 0x34, 0x45, 0x2d, 0x30, 0x34, 0x41, 0x32, 0x2d, 0x34, 0x42, 0x33, 0x37, 0x2d, 0x39, 0x36, 0x46, 0x38, 0x2d, 0x30, 0x38, 0x41, 0x43, 0x44, 0x42, 0x36, 0x31, 0x30, 0x38, 0x37, 0x34, 0x7d, 0x0d, 0x0a, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x49, 0x44, 0x3a, 0x20, 0x39, 0x36, 0x32, 0x32, 0x38, 0x30, 0x37, 0x35, 0x32, 0x0d, 0x0a, 0x53, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x53, 0x74, 0x61, 0x74, 0x65, 0x3a, 0x20, 0x30, 0x0d, 0x0a, 0x41, 0x70, 0x70, 0x49, 0x44, 0x3a, 0x20, 0x33, 0x35, 0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x00, 0x00];
            //let msg_command : [u8;626] = [0x4d, 0x53, 0x47, 0x20, 0x35, 0x20, 0x44, 0x20, 0x36, 0x31, 0x35, 0x0d, 0x0a, 0x4d, 0x49, 0x4d, 0x45, 0x2d, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x3a, 0x20, 0x31, 0x2e, 0x30, 0x0d, 0x0a, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x54, 0x79, 0x70, 0x65, 0x3a, 0x20, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x78, 0x2d, 0x6d, 0x73, 0x6e, 0x6d, 0x73, 0x67, 0x72, 0x70, 0x32, 0x70, 0x0d, 0x0a, 0x50, 0x32, 0x50, 0x2d, 0x44, 0x65, 0x73, 0x74, 0x3a, 0x20, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x33, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x0d, 0x0a, 0x50, 0x32, 0x50, 0x2d, 0x53, 0x72, 0x63, 0x3a, 0x20, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x6e, 0xdb, 0x43, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xba, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xba, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x8c, 0xdb, 0x43, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49, 0x4e, 0x56, 0x49, 0x54, 0x45, 0x20, 0x4d, 0x53, 0x4e, 0x4d, 0x53, 0x47, 0x52, 0x3a, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x33, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x4d, 0x53, 0x4e, 0x53, 0x4c, 0x50, 0x2f, 0x31, 0x2e, 0x30, 0x0d, 0x0a, 0x54, 0x6f, 0x3a, 0x20, 0x3c, 0x6d, 0x73, 0x6e, 0x6d, 0x73, 0x67, 0x72, 0x3a, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x33, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x3e, 0x0d, 0x0a, 0x46, 0x72, 0x6f, 0x6d, 0x3a, 0x20, 0x3c, 0x6d, 0x73, 0x6e, 0x6d, 0x73, 0x67, 0x72, 0x3a, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x3e, 0x0d, 0x0a, 0x56, 0x69, 0x61, 0x3a, 0x20, 0x4d, 0x53, 0x4e, 0x53, 0x4c, 0x50, 0x2f, 0x31, 0x2e, 0x30, 0x2f, 0x54, 0x4c, 0x50, 0x20, 0x3b, 0x62, 0x72, 0x61, 0x6e, 0x63, 0x68, 0x3d, 0x7b, 0x36, 0x46, 0x43, 0x36, 0x45, 0x31, 0x34, 0x37, 0x2d, 0x45, 0x43, 0x36, 0x31, 0x2d, 0x34, 0x44, 0x42, 0x34, 0x2d, 0x38, 0x39, 0x32, 0x39, 0x2d, 0x33, 0x33, 0x39, 0x38, 0x44, 0x31, 0x37, 0x30, 0x36, 0x46, 0x33, 0x37, 0x7d, 0x0d, 0x0a, 0x43, 0x53, 0x65, 0x71, 0x3a, 0x20, 0x30, 0x20, 0x0d, 0x0a, 0x43, 0x61, 0x6c, 0x6c, 0x2d, 0x49, 0x44, 0x3a, 0x20, 0x7b, 0x38, 0x36, 0x36, 0x39, 0x46, 0x33, 0x30, 0x31, 0x2d, 0x32, 0x45, 0x46, 0x43, 0x2d, 0x34, 0x35, 0x36, 0x44, 0x2d, 0x39, 0x33, 0x41, 0x34, 0x2d, 0x31, 0x31, 0x36, 0x33, 0x39, 0x42, 0x37, 0x34, 0x36, 0x44, 0x42, 0x41, 0x7d, 0x0d, 0x0a, 0x4d, 0x61, 0x78, 0x2d, 0x46, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x73, 0x3a, 0x20, 0x30, 0x0d, 0x0a, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x54, 0x79, 0x70, 0x65, 0x3a, 0x20, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x78, 0x2d, 0x6d, 0x73, 0x6e, 0x6d, 0x73, 0x67, 0x72, 0x2d, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x72, 0x65, 0x71, 0x62, 0x6f, 0x64, 0x79, 0x0d, 0x0a, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x3a, 0x20, 0x31, 0x30, 0x35, 0x0d, 0x0a, 0x0d, 0x0a, 0x45, 0x55, 0x46, 0x2d, 0x47, 0x55, 0x49, 0x44, 0x3a, 0x20, 0x7b, 0x34, 0x31, 0x44, 0x33, 0x45, 0x37, 0x34, 0x45, 0x2d, 0x30, 0x34, 0x41, 0x32, 0x2d, 0x34, 0x42, 0x33, 0x37, 0x2d, 0x39, 0x36, 0x46, 0x38, 0x2d, 0x30, 0x38, 0x41, 0x43, 0x44, 0x42, 0x36, 0x31, 0x30, 0x38, 0x37, 0x34, 0x7d, 0x0d, 0x0a, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x49, 0x44, 0x3a, 0x20, 0x31, 0x30, 0x39, 0x34, 0x39, 0x36, 0x35, 0x36, 0x34, 0x32, 0x0d, 0x0a, 0x53, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x53, 0x74, 0x61, 0x74, 0x65, 0x3a, 0x20, 0x30, 0x0d, 0x0a, 0x41, 0x70, 0x70, 0x49, 0x44, 0x3a, 0x20, 0x33, 0x35, 0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x00, 0x00];
            let mut parser: RawCommandParser = RawCommandParser::new();

            let msg_command : [u8;1008] = [0x4d, 0x53, 0x47, 0x20, 0x32, 0x36, 0x20, 0x44, 0x20, 0x39, 0x39, 0x34, 0x0d, 0x0a, 0x4d, 0x49, 0x4d, 0x45, 0x2d, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x3a, 0x20, 0x31, 0x2e, 0x30, 0x0d, 0x0a, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x54, 0x79, 0x70, 0x65, 0x3a, 0x20, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x78, 0x2d, 0x6d, 0x73, 0x6e, 0x6d, 0x73, 0x67, 0x72, 0x70, 0x32, 0x70, 0x0d, 0x0a, 0x50, 0x32, 0x50, 0x2d, 0x44, 0x65, 0x73, 0x74, 0x3a, 0x20, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x33, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x3b, 0x7b, 0x37, 0x37, 0x63, 0x34, 0x36, 0x61, 0x38, 0x66, 0x2d, 0x33, 0x33, 0x61, 0x33, 0x2d, 0x35, 0x32, 0x38, 0x32, 0x2d, 0x39, 0x61, 0x35, 0x64, 0x2d, 0x39, 0x30, 0x35, 0x65, 0x63, 0x64, 0x33, 0x65, 0x62, 0x30, 0x36, 0x39, 0x7d, 0x0d, 0x0a, 0x50, 0x32, 0x50, 0x2d, 0x53, 0x72, 0x63, 0x3a, 0x20, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x3b, 0x7b, 0x66, 0x35, 0x32, 0x39, 0x37, 0x33, 0x62, 0x36, 0x2d, 0x63, 0x39, 0x32, 0x36, 0x2d, 0x34, 0x62, 0x61, 0x64, 0x2d, 0x39, 0x62, 0x61, 0x38, 0x2d, 0x37, 0x63, 0x31, 0x65, 0x38, 0x34, 0x30, 0x65, 0x34, 0x61, 0x62, 0x30, 0x7d, 0x0d, 0x0a, 0x0d, 0x0a, 0x08, 0x00, 0x03, 0x0f, 0x32, 0x52, 0xd1, 0xec, 0x08, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x49, 0x4e, 0x56, 0x49, 0x54, 0x45, 0x20, 0x4d, 0x53, 0x4e, 0x4d, 0x53, 0x47, 0x52, 0x3a, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x33, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x3b, 0x7b, 0x37, 0x37, 0x63, 0x34, 0x36, 0x61, 0x38, 0x66, 0x2d, 0x33, 0x33, 0x61, 0x33, 0x2d, 0x35, 0x32, 0x38, 0x32, 0x2d, 0x39, 0x61, 0x35, 0x64, 0x2d, 0x39, 0x30, 0x35, 0x65, 0x63, 0x64, 0x33, 0x65, 0x62, 0x30, 0x36, 0x39, 0x7d, 0x20, 0x4d, 0x53, 0x4e, 0x53, 0x4c, 0x50, 0x2f, 0x31, 0x2e, 0x30, 0x0d, 0x0a, 0x54, 0x6f, 0x3a, 0x20, 0x3c, 0x6d, 0x73, 0x6e, 0x6d, 0x73, 0x67, 0x72, 0x3a, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x33, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x3b, 0x7b, 0x37, 0x37, 0x63, 0x34, 0x36, 0x61, 0x38, 0x66, 0x2d, 0x33, 0x33, 0x61, 0x33, 0x2d, 0x35, 0x32, 0x38, 0x32, 0x2d, 0x39, 0x61, 0x35, 0x64, 0x2d, 0x39, 0x30, 0x35, 0x65, 0x63, 0x64, 0x33, 0x65, 0x62, 0x30, 0x36, 0x39, 0x7d, 0x3e, 0x0d, 0x0a, 0x46, 0x72, 0x6f, 0x6d, 0x3a, 0x20, 0x3c, 0x6d, 0x73, 0x6e, 0x6d, 0x73, 0x67, 0x72, 0x3a, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x3b, 0x7b, 0x66, 0x35, 0x32, 0x39, 0x37, 0x33, 0x62, 0x36, 0x2d, 0x63, 0x39, 0x32, 0x36, 0x2d, 0x34, 0x62, 0x61, 0x64, 0x2d, 0x39, 0x62, 0x61, 0x38, 0x2d, 0x37, 0x63, 0x31, 0x65, 0x38, 0x34, 0x30, 0x65, 0x34, 0x61, 0x62, 0x30, 0x7d, 0x3e, 0x0d, 0x0a, 0x56, 0x69, 0x61, 0x3a, 0x20, 0x4d, 0x53, 0x4e, 0x53, 0x4c, 0x50, 0x2f, 0x31, 0x2e, 0x30, 0x2f, 0x54, 0x4c, 0x50, 0x20, 0x3b, 0x62, 0x72, 0x61, 0x6e, 0x63, 0x68, 0x3d, 0x7b, 0x44, 0x37, 0x36, 0x34, 0x44, 0x32, 0x39, 0x38, 0x2d, 0x33, 0x37, 0x42, 0x38, 0x2d, 0x34, 0x43, 0x38, 0x41, 0x2d, 0x42, 0x39, 0x44, 0x36, 0x2d, 0x45, 0x38, 0x31, 0x31, 0x41, 0x45, 0x44, 0x31, 0x43, 0x39, 0x38, 0x31, 0x7d, 0x0d, 0x0a, 0x43, 0x53, 0x65, 0x71, 0x3a, 0x20, 0x30, 0x20, 0x0d, 0x0a, 0x43, 0x61, 0x6c, 0x6c, 0x2d, 0x49, 0x44, 0x3a, 0x20, 0x7b, 0x30, 0x32, 0x42, 0x42, 0x39, 0x45, 0x41, 0x35, 0x2d, 0x46, 0x30, 0x44, 0x42, 0x2d, 0x34, 0x31, 0x42, 0x46, 0x2d, 0x38, 0x30, 0x45, 0x33, 0x2d, 0x32, 0x39, 0x31, 0x43, 0x42, 0x39, 0x38, 0x46, 0x39, 0x37, 0x39, 0x33, 0x7d, 0x0d, 0x0a, 0x4d, 0x61, 0x78, 0x2d, 0x46, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x73, 0x3a, 0x20, 0x30, 0x0d, 0x0a, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x54, 0x79, 0x70, 0x65, 0x3a, 0x20, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x78, 0x2d, 0x6d, 0x73, 0x6e, 0x6d, 0x73, 0x67, 0x72, 0x2d, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x72, 0x65, 0x71, 0x62, 0x6f, 0x64, 0x79, 0x0d, 0x0a, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x3a, 0x20, 0x33, 0x32, 0x33, 0x0d, 0x0a, 0x0d, 0x0a, 0x4e, 0x65, 0x74, 0x49, 0x44, 0x3a, 0x20, 0x31, 0x30, 0x34, 0x30, 0x32, 0x39, 0x36, 0x31, 0x32, 0x38, 0x0d, 0x0a, 0x43, 0x6f, 0x6e, 0x6e, 0x2d, 0x54, 0x79, 0x70, 0x65, 0x3a, 0x20, 0x46, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x0d, 0x0a, 0x54, 0x43, 0x50, 0x2d, 0x43, 0x6f, 0x6e, 0x6e, 0x2d, 0x54, 0x79, 0x70, 0x65, 0x3a, 0x20, 0x46, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x0d, 0x0a, 0x55, 0x50, 0x6e, 0x50, 0x4e, 0x61, 0x74, 0x3a, 0x20, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x0d, 0x0a, 0x49, 0x43, 0x46, 0x3a, 0x20, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x0d, 0x0a, 0x49, 0x50, 0x76, 0x36, 0x2d, 0x67, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x3a, 0x20, 0x32, 0x61, 0x30, 0x32, 0x3a, 0x61, 0x30, 0x33, 0x66, 0x3a, 0x61, 0x31, 0x33, 0x65, 0x3a, 0x32, 0x36, 0x30, 0x30, 0x3a, 0x38, 0x34, 0x35, 0x36, 0x3a, 0x66, 0x61, 0x37, 0x65, 0x3a, 0x33, 0x30, 0x31, 0x62, 0x3a, 0x63, 0x34, 0x35, 0x34, 0x0d, 0x0a, 0x43, 0x61, 0x70, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x69, 0x65, 0x73, 0x2d, 0x46, 0x6c, 0x61, 0x67, 0x73, 0x3a, 0x20, 0x31, 0x0d, 0x0a, 0x4e, 0x61, 0x74, 0x2d, 0x54, 0x72, 0x61, 0x76, 0x2d, 0x4d, 0x73, 0x67, 0x2d, 0x54, 0x79, 0x70, 0x65, 0x3a, 0x20, 0x57, 0x4c, 0x58, 0x2d, 0x4e, 0x61, 0x74, 0x2d, 0x54, 0x72, 0x61, 0x76, 0x2d, 0x4d, 0x73, 0x67, 0x2d, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x2d, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x2d, 0x52, 0x65, 0x71, 0x0d, 0x0a, 0x42, 0x72, 0x69, 0x64, 0x67, 0x65, 0x73, 0x3a, 0x20, 0x54, 0x52, 0x55, 0x44, 0x50, 0x76, 0x31, 0x20, 0x54, 0x43, 0x50, 0x76, 0x31, 0x20, 0x53, 0x42, 0x42, 0x72, 0x69, 0x64, 0x67, 0x65, 0x20, 0x54, 0x55, 0x52, 0x4e, 0x76, 0x31, 0x0d, 0x0a, 0x48, 0x61, 0x73, 0x68, 0x65, 0x64, 0x2d, 0x4e, 0x6f, 0x6e, 0x63, 0x65, 0x3a, 0x20, 0x7b, 0x42, 0x46, 0x33, 0x30, 0x46, 0x42, 0x45, 0x37, 0x2d, 0x32, 0x39, 0x34, 0x31, 0x2d, 0x43, 0x38, 0x32, 0x45, 0x2d, 0x33, 0x35, 0x39, 0x30, 0x2d, 0x35, 0x37, 0x33, 0x31, 0x43, 0x38, 0x32, 0x34, 0x42, 0x42, 0x45, 0x46, 0x7d, 0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00];

            let msg_as_str = unsafe {from_utf8_unchecked(&msg_command)}.to_owned();
            info!("MSG command: {}", &msg_as_str);

            let commands = parser.parse_message(msg_as_str.as_str());
            let temp = commands.unwrap();
            let command = temp.get(0).unwrap();
            info!("MSG command payload: {}", command.payload.as_str());

            let msg = MsgPayload::from_str(command.payload.as_str()).unwrap();
            info!("msg payload payload: {}", msg.body.as_str());
            let p2p_transport_packet = P2PTransportPacket::from_str(msg.body.as_str()).unwrap();
            let p2p_transport_packet_serialized = p2p_transport_packet.to_string();

            info!("msg payload payload serialize test: {}", &p2p_transport_packet_serialized);

            assert_eq!(msg.body.as_bytes(), p2p_transport_packet_serialized.as_bytes());

            let original_p2p_payload = &p2p_transport_packet.get_payload().unwrap();
            let p2p_payload_serialized = original_p2p_payload.to_string();
            let p2p_payload_deserialized = P2PPayload::deserialize(p2p_payload_serialized.as_bytes(), p2p_transport_packet.payload_length).unwrap();

            assert_eq!(p2p_payload_deserialized.header_length, original_p2p_payload.header_length);
            assert_eq!(p2p_payload_deserialized.tf_combination, original_p2p_payload.tf_combination);

            let slp_payload = original_p2p_payload.get_payload_as_slp().unwrap();

            info!("slp payload: {}", slp_payload);
        }

        #[test]
        #[allow(rustc::invalid_from_utf8_unchecked)]
        fn test_deserialize_msg_command_containing_slp_payload_with_tlvs() {

            let mut parser = RawCommandParser::new();

            let msg_command : [u8;807] = [ 0x4d, 0x53, 0x47, 0x20, 0x33, 0x20, 0x44, 0x20, 0x37, 0x39, 0x34, 0x0d, 0x0a, 0x4d, 0x49, 0x4d, 0x45, 0x2d, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x3a, 0x20, 0x31, 0x2e, 0x30, 0x0d, 0x0a, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x54, 0x79, 0x70, 0x65, 0x3a, 0x20, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x78, 0x2d, 0x6d, 0x73, 0x6e, 0x6d, 0x73, 0x67, 0x72, 0x70, 0x32, 0x70, 0x0d, 0x0a, 0x50, 0x32, 0x50, 0x2d, 0x44, 0x65, 0x73, 0x74, 0x3a, 0x20, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x33, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x3b, 0x7b, 0x37, 0x37, 0x63, 0x34, 0x36, 0x61, 0x38, 0x66, 0x2d, 0x33, 0x33, 0x61, 0x33, 0x2d, 0x35, 0x32, 0x38, 0x32, 0x2d, 0x39, 0x61, 0x35, 0x64, 0x2d, 0x39, 0x30, 0x35, 0x65, 0x63, 0x64, 0x33, 0x65, 0x62, 0x30, 0x36, 0x39, 0x7d, 0x0d, 0x0a, 0x50, 0x32, 0x50, 0x2d, 0x53, 0x72, 0x63, 0x3a, 0x20, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x3b, 0x7b, 0x66, 0x35, 0x32, 0x39, 0x37, 0x33, 0x62, 0x36, 0x2d, 0x63, 0x39, 0x32, 0x36, 0x2d, 0x34, 0x62, 0x61, 0x64, 0x2d, 0x39, 0x62, 0x61, 0x38, 0x2d, 0x37, 0x63, 0x31, 0x65, 0x38, 0x34, 0x30, 0x65, 0x34, 0x61, 0x62, 0x30, 0x7d, 0x0d, 0x0a, 0x0d, 0x0a, 0x18, 0x03, 0x02, 0x37, 0xe1, 0x62, 0x3d, 0xf3, 0x01, 0x0c, 0x00, 0x02, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x0f, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49, 0x4e, 0x56, 0x49, 0x54, 0x45, 0x20, 0x4d, 0x53, 0x4e, 0x4d, 0x53, 0x47, 0x52, 0x3a, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x33, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x3b, 0x7b, 0x37, 0x37, 0x63, 0x34, 0x36, 0x61, 0x38, 0x66, 0x2d, 0x33, 0x33, 0x61, 0x33, 0x2d, 0x35, 0x32, 0x38, 0x32, 0x2d, 0x39, 0x61, 0x35, 0x64, 0x2d, 0x39, 0x30, 0x35, 0x65, 0x63, 0x64, 0x33, 0x65, 0x62, 0x30, 0x36, 0x39, 0x7d, 0x20, 0x4d, 0x53, 0x4e, 0x53, 0x4c, 0x50, 0x2f, 0x31, 0x2e, 0x30, 0x0d, 0x0a, 0x54, 0x6f, 0x3a, 0x20, 0x3c, 0x6d, 0x73, 0x6e, 0x6d, 0x73, 0x67, 0x72, 0x3a, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x33, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x3b, 0x7b, 0x37, 0x37, 0x63, 0x34, 0x36, 0x61, 0x38, 0x66, 0x2d, 0x33, 0x33, 0x61, 0x33, 0x2d, 0x35, 0x32, 0x38, 0x32, 0x2d, 0x39, 0x61, 0x35, 0x64, 0x2d, 0x39, 0x30, 0x35, 0x65, 0x63, 0x64, 0x33, 0x65, 0x62, 0x30, 0x36, 0x39, 0x7d, 0x3e, 0x0d, 0x0a, 0x46, 0x72, 0x6f, 0x6d, 0x3a, 0x20, 0x3c, 0x6d, 0x73, 0x6e, 0x6d, 0x73, 0x67, 0x72, 0x3a, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x3b, 0x7b, 0x66, 0x35, 0x32, 0x39, 0x37, 0x33, 0x62, 0x36, 0x2d, 0x63, 0x39, 0x32, 0x36, 0x2d, 0x34, 0x62, 0x61, 0x64, 0x2d, 0x39, 0x62, 0x61, 0x38, 0x2d, 0x37, 0x63, 0x31, 0x65, 0x38, 0x34, 0x30, 0x65, 0x34, 0x61, 0x62, 0x30, 0x7d, 0x3e, 0x0d, 0x0a, 0x56, 0x69, 0x61, 0x3a, 0x20, 0x4d, 0x53, 0x4e, 0x53, 0x4c, 0x50, 0x2f, 0x31, 0x2e, 0x30, 0x2f, 0x54, 0x4c, 0x50, 0x20, 0x3b, 0x62, 0x72, 0x61, 0x6e, 0x63, 0x68, 0x3d, 0x7b, 0x44, 0x38, 0x41, 0x38, 0x42, 0x44, 0x45, 0x32, 0x2d, 0x30, 0x46, 0x41, 0x37, 0x2d, 0x34, 0x46, 0x32, 0x37, 0x2d, 0x39, 0x34, 0x30, 0x38, 0x2d, 0x44, 0x43, 0x42, 0x36, 0x31, 0x34, 0x32, 0x46, 0x38, 0x35, 0x45, 0x42, 0x7d, 0x0d, 0x0a, 0x43, 0x53, 0x65, 0x71, 0x3a, 0x20, 0x30, 0x20, 0x0d, 0x0a, 0x43, 0x61, 0x6c, 0x6c, 0x2d, 0x49, 0x44, 0x3a, 0x20, 0x7b, 0x41, 0x38, 0x37, 0x44, 0x37, 0x38, 0x33, 0x41, 0x2d, 0x35, 0x46, 0x44, 0x36, 0x2d, 0x34, 0x39, 0x35, 0x45, 0x2d, 0x39, 0x43, 0x46, 0x34, 0x2d, 0x31, 0x38, 0x43, 0x33, 0x37, 0x41, 0x35, 0x41, 0x39, 0x39, 0x45, 0x46, 0x7d, 0x0d, 0x0a, 0x4d, 0x61, 0x78, 0x2d, 0x46, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x73, 0x3a, 0x20, 0x30, 0x0d, 0x0a, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x54, 0x79, 0x70, 0x65, 0x3a, 0x20, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x78, 0x2d, 0x6d, 0x73, 0x6e, 0x6d, 0x73, 0x67, 0x72, 0x2d, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x72, 0x65, 0x71, 0x62, 0x6f, 0x64, 0x79, 0x0d, 0x0a, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x3a, 0x20, 0x31, 0x30, 0x35, 0x0d, 0x0a, 0x0d, 0x0a, 0x45, 0x55, 0x46, 0x2d, 0x47, 0x55, 0x49, 0x44, 0x3a, 0x20, 0x7b, 0x34, 0x31, 0x44, 0x33, 0x45, 0x37, 0x34, 0x45, 0x2d, 0x30, 0x34, 0x41, 0x32, 0x2d, 0x34, 0x42, 0x33, 0x37, 0x2d, 0x39, 0x36, 0x46, 0x38, 0x2d, 0x30, 0x38, 0x41, 0x43, 0x44, 0x42, 0x36, 0x31, 0x30, 0x38, 0x37, 0x34, 0x7d, 0x0d, 0x0a, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x49, 0x44, 0x3a, 0x20, 0x33, 0x33, 0x38, 0x39, 0x31, 0x33, 0x33, 0x38, 0x33, 0x38, 0x0d, 0x0a, 0x41, 0x70, 0x70, 0x49, 0x44, 0x3a, 0x20, 0x33, 0x35, 0x0d, 0x0a, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x46, 0x6c, 0x61, 0x67, 0x73, 0x3a, 0x20, 0x31, 0x36, 0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00];

            let msg_as_str = unsafe {from_utf8_unchecked(&msg_command)}.to_owned();
            info!("MSG command: {}", &msg_as_str);

            let commands = parser.parse_message(msg_as_str.as_str());

            let temp = commands.unwrap();
            let command = temp.get(0).unwrap();
            info!("MSG command payload: {}", command.payload.as_str());

            let msg = MsgPayload::from_str(command.payload.as_str()).unwrap();
            info!("msg payload payload: {}", msg.body.as_str());
            let p2p_transport_packet = P2PTransportPacket::from_str(msg.body.as_str()).unwrap();
            let p2p_transport_packet_serialized = p2p_transport_packet.to_string();

            info!("msg payload payload serialize test: {}", &p2p_transport_packet_serialized);

            assert_eq!(p2p_transport_packet.tlvs.len(), 1);
            assert!(p2p_transport_packet.get_ack_tlv().is_none());
            assert!(p2p_transport_packet.get_client_info_tlv().is_some());

            assert_eq!(msg.body.as_bytes(), p2p_transport_packet_serialized.as_bytes());



            let original_p2p_payload = &p2p_transport_packet.get_payload().unwrap();
            let p2p_payload_serialized = original_p2p_payload.to_string();
            let p2p_payload_deserialized = P2PPayload::deserialize(p2p_payload_serialized.as_bytes(), p2p_transport_packet.payload_length).unwrap();

            assert_eq!(p2p_payload_deserialized.header_length, original_p2p_payload.header_length);
            assert_eq!(p2p_payload_deserialized.tf_combination, original_p2p_payload.tf_combination);

            let slp_payload = original_p2p_payload.get_payload_as_slp().unwrap();

            info!("slp payload: {}", slp_payload);
        }

        #[test]
        #[allow(rustc::invalid_from_utf8_unchecked)]
        fn test_deserialize_msg_command_containing_no_p2p_payload() {

            let mut parser = RawCommandParser::new();

            let msg_command : [u8;225] = [ 0x4d, 0x53, 0x47, 0x20, 0x36, 0x34, 0x20, 0x44, 0x20, 0x32, 0x31, 0x31, 0x0d, 0x0a, 0x4d, 0x49, 0x4d, 0x45, 0x2d, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x3a, 0x20, 0x31, 0x2e, 0x30, 0x0d, 0x0a, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x54, 0x79, 0x70, 0x65, 0x3a, 0x20, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x78, 0x2d, 0x6d, 0x73, 0x6e, 0x6d, 0x73, 0x67, 0x72, 0x70, 0x32, 0x70, 0x0d, 0x0a, 0x50, 0x32, 0x50, 0x2d, 0x44, 0x65, 0x73, 0x74, 0x3a, 0x20, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x33, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x3b, 0x7b, 0x37, 0x37, 0x63, 0x34, 0x36, 0x61, 0x38, 0x66, 0x2d, 0x33, 0x33, 0x61, 0x33, 0x2d, 0x35, 0x32, 0x38, 0x32, 0x2d, 0x39, 0x61, 0x35, 0x64, 0x2d, 0x39, 0x30, 0x35, 0x65, 0x63, 0x64, 0x33, 0x65, 0x62, 0x30, 0x36, 0x39, 0x7d, 0x0d, 0x0a, 0x50, 0x32, 0x50, 0x2d, 0x53, 0x72, 0x63, 0x3a, 0x20, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x3b, 0x7b, 0x66, 0x35, 0x32, 0x39, 0x37, 0x33, 0x62, 0x36, 0x2d, 0x63, 0x39, 0x32, 0x36, 0x2d, 0x34, 0x62, 0x61, 0x64, 0x2d, 0x39, 0x62, 0x61, 0x38, 0x2d, 0x37, 0x63, 0x31, 0x65, 0x38, 0x34, 0x30, 0x65, 0x34, 0x61, 0x62, 0x30, 0x7d, 0x0d, 0x0a, 0x0d, 0x0a, 0x08, 0x02, 0x00, 0x00, 0xe0, 0x93, 0xf1, 0x0b, 0x00, 0x00, 0x00, 0x00];

            let msg_as_str = unsafe {from_utf8_unchecked(&msg_command)}.to_owned();
            info!("MSG command: {}", &msg_as_str);

            let commands = parser.parse_message(msg_as_str.as_str());
            let temp = commands.unwrap();

            let command = temp.get(0).unwrap();
            info!("MSG command payload: {}", command.payload.as_str());

            let msg = MsgPayload::from_str(command.payload.as_str()).unwrap();
            info!("msg payload payload: {}", msg.body.as_str());
            let p2p_transport_packet = P2PTransportPacket::from_str(msg.body.as_str()).unwrap();
            let p2p_transport_packet_serialized = p2p_transport_packet.to_string();

            info!("msg payload payload serialize test: {}", &p2p_transport_packet_serialized);

            assert_eq!(msg.body.as_bytes(), p2p_transport_packet_serialized.as_bytes());
        }


        #[test]
        fn tlv_is_type_test() {
            let ack_tlv = TLVFactory::get_ack(0);

            assert!(ack_tlv.is_type(&ValueType::AckSequenceNumber));
        }

        #[test]
        fn get_tlv_for_type_in_packet_test() {
            let ack = P2PTransportPacketFactory::get_ack(1);
            let tlv = ack.get_tlv_for_type(&ValueType::AckSequenceNumber);

            let ack_tlv = ack.get_ack_tlv();

            let seq = ack.get_next_ack_sequence_number();



            assert!(tlv.is_some());
            assert!(ack_tlv.is_some());


            let seq_number = BigEndian::read_u32(ack_tlv.unwrap().value.as_slice());

            assert_eq!(seq_number, 1);

        }


        #[test]
        fn test_serialize_slp_payload_200_ok() {

            // let mut invite_slp_payload = SlpPayload::new();
            // invite_slp_payload.first_line = String::from("INVITE MSNMSGR:aeontest3@shl.local;{77c46a8f-33a3-5282-9a5d-905ecd3eb069} MSNSLP/1.0");

            // invite_slp_payload.add_header(String::from("Max-Forwards"), String::from("0"));
            // invite_slp_payload.add_header(String::from("Content-Type"), String::from("application/x-msnmsgr-transreqbody"));
            // invite_slp_payload.add_header(String::from("To"), String::from("<msnmsgr:aeontest3@shl.local;{77c46a8f-33a3-5282-9a5d-905ecd3eb069}>"));
            // invite_slp_payload.add_header(String::from("From"), String::from("<msnmsgr:aeontest@shl.local;{f52973b6-c926-4bad-9ba8-7c1e840e4ab0}>"));
            // invite_slp_payload.add_header(String::from("Via"), String::from("MSNSLP/1.0/TLP ;branch={D764D298-37B8-4C8A-B9D6-E811AED1C981}"));
            // invite_slp_payload.add_header(String::from("CSeq"), String::from("0"));
            // invite_slp_payload.add_header(String::from("Call-ID"), String::from("{02BB9EA5-F0DB-41BF-80E3-291CB98F9793}"));

            // invite_slp_payload.add_body_property(String::from("NetID"), String::from("1040296128"));
            // invite_slp_payload.add_body_property(String::from("Conn-Type"), String::from("Firewall"));
            // invite_slp_payload.add_body_property(String::from("TCP-Conn-Type"), String::from("Firewall"));
            // invite_slp_payload.add_body_property(String::from("UPnPNat"), String::from("false"));
            // invite_slp_payload.add_body_property(String::from("ICF"), String::from("false"));
            // invite_slp_payload.add_body_property(String::from("Capabilities-Flags"), String::from("1"));
            // invite_slp_payload.add_body_property(String::from("Nat-Trav-Msg-Type"), String::from("WLX-Nat-Trav-Msg-Direct-Connect-Req"));
            // invite_slp_payload.add_body_property(String::from("Bridges"), String::from("TRUDPv1 TCPv1 SBBridge TURNv1"));
            // invite_slp_payload.add_body_property(String::from("Hashed-Nonce"), String::from("{BF30FBE7-2941-C82E-3590-5731C824BBEF}"));

            // let result = SlpPayloadFactory::get_200_ok(&invite_slp_payload);

            // assert_eq!(result.first_line, String::from("MSNSLP/1.0 200 OK"));
            // assert_eq!(result.get_header(&String::from("CSeq")).unwrap(), &String::from("1"));
            // assert_eq!(result.get_header(&String::from("To")).unwrap(), &String::from("<msnmsgr:aeontest@shl.local;{f52973b6-c926-4bad-9ba8-7c1e840e4ab0}>"));
            // assert_eq!(result.get_header(&String::from("From")).unwrap(), &String::from("<msnmsgr:aeontest3@shl.local;{77c46a8f-33a3-5282-9a5d-905ecd3eb069}>"));
            // assert_eq!(result.get_body_property(&String::from("Bridge")).unwrap(), &String::from("SBBridge"));

        }

        #[test]
        pub fn test_complete_200_ok() {

        //     let msg_command : [u8;806] = [ 0x4d, 0x53, 0x47, 0x20, 0x33, 0x20, 0x44, 0x20, 0x37, 0x39, 0x34, 0x0d, 0x0a, 0x4d, 0x49, 0x4d, 0x45, 0x2d, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x3a, 0x20, 0x31, 0x2e, 0x30, 0x0d, 0x0a, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x54, 0x79, 0x70, 0x65, 0x3a, 0x20, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x78, 0x2d, 0x6d, 0x73, 0x6e, 0x6d, 0x73, 0x67, 0x72, 0x70, 0x32, 0x70, 0x0d, 0x0a, 0x50, 0x32, 0x50, 0x2d, 0x44, 0x65, 0x73, 0x74, 0x3a, 0x20, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x33, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x3b, 0x7b, 0x37, 0x37, 0x63, 0x34, 0x36, 0x61, 0x38, 0x66, 0x2d, 0x33, 0x33, 0x61, 0x33, 0x2d, 0x35, 0x32, 0x38, 0x32, 0x2d, 0x39, 0x61, 0x35, 0x64, 0x2d, 0x39, 0x30, 0x35, 0x65, 0x63, 0x64, 0x33, 0x65, 0x62, 0x30, 0x36, 0x39, 0x7d, 0x0d, 0x0a, 0x50, 0x32, 0x50, 0x2d, 0x53, 0x72, 0x63, 0x3a, 0x20, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x3b, 0x7b, 0x66, 0x35, 0x32, 0x39, 0x37, 0x33, 0x62, 0x36, 0x2d, 0x63, 0x39, 0x32, 0x36, 0x2d, 0x34, 0x62, 0x61, 0x64, 0x2d, 0x39, 0x62, 0x61, 0x38, 0x2d, 0x37, 0x63, 0x31, 0x65, 0x38, 0x34, 0x30, 0x65, 0x34, 0x61, 0x62, 0x30, 0x7d, 0x0d, 0x0a, 0x0d, 0x0a, 0x18, 0x03, 0x02, 0x37, 0xe1, 0x62, 0x3d, 0xf3, 0x01, 0x0c, 0x00, 0x02, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x0f, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49, 0x4e, 0x56, 0x49, 0x54, 0x45, 0x20, 0x4d, 0x53, 0x4e, 0x4d, 0x53, 0x47, 0x52, 0x3a, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x33, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x3b, 0x7b, 0x37, 0x37, 0x63, 0x34, 0x36, 0x61, 0x38, 0x66, 0x2d, 0x33, 0x33, 0x61, 0x33, 0x2d, 0x35, 0x32, 0x38, 0x32, 0x2d, 0x39, 0x61, 0x35, 0x64, 0x2d, 0x39, 0x30, 0x35, 0x65, 0x63, 0x64, 0x33, 0x65, 0x62, 0x30, 0x36, 0x39, 0x7d, 0x20, 0x4d, 0x53, 0x4e, 0x53, 0x4c, 0x50, 0x2f, 0x31, 0x2e, 0x30, 0x0d, 0x0a, 0x54, 0x6f, 0x3a, 0x20, 0x3c, 0x6d, 0x73, 0x6e, 0x6d, 0x73, 0x67, 0x72, 0x3a, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x33, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x3b, 0x7b, 0x37, 0x37, 0x63, 0x34, 0x36, 0x61, 0x38, 0x66, 0x2d, 0x33, 0x33, 0x61, 0x33, 0x2d, 0x35, 0x32, 0x38, 0x32, 0x2d, 0x39, 0x61, 0x35, 0x64, 0x2d, 0x39, 0x30, 0x35, 0x65, 0x63, 0x64, 0x33, 0x65, 0x62, 0x30, 0x36, 0x39, 0x7d, 0x3e, 0x0d, 0x0a, 0x46, 0x72, 0x6f, 0x6d, 0x3a, 0x20, 0x3c, 0x6d, 0x73, 0x6e, 0x6d, 0x73, 0x67, 0x72, 0x3a, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x3b, 0x7b, 0x66, 0x35, 0x32, 0x39, 0x37, 0x33, 0x62, 0x36, 0x2d, 0x63, 0x39, 0x32, 0x36, 0x2d, 0x34, 0x62, 0x61, 0x64, 0x2d, 0x39, 0x62, 0x61, 0x38, 0x2d, 0x37, 0x63, 0x31, 0x65, 0x38, 0x34, 0x30, 0x65, 0x34, 0x61, 0x62, 0x30, 0x7d, 0x3e, 0x0d, 0x0a, 0x56, 0x69, 0x61, 0x3a, 0x20, 0x4d, 0x53, 0x4e, 0x53, 0x4c, 0x50, 0x2f, 0x31, 0x2e, 0x30, 0x2f, 0x54, 0x4c, 0x50, 0x20, 0x3b, 0x62, 0x72, 0x61, 0x6e, 0x63, 0x68, 0x3d, 0x7b, 0x44, 0x38, 0x41, 0x38, 0x42, 0x44, 0x45, 0x32, 0x2d, 0x30, 0x46, 0x41, 0x37, 0x2d, 0x34, 0x46, 0x32, 0x37, 0x2d, 0x39, 0x34, 0x30, 0x38, 0x2d, 0x44, 0x43, 0x42, 0x36, 0x31, 0x34, 0x32, 0x46, 0x38, 0x35, 0x45, 0x42, 0x7d, 0x0d, 0x0a, 0x43, 0x53, 0x65, 0x71, 0x3a, 0x20, 0x30, 0x20, 0x0d, 0x0a, 0x43, 0x61, 0x6c, 0x6c, 0x2d, 0x49, 0x44, 0x3a, 0x20, 0x7b, 0x41, 0x38, 0x37, 0x44, 0x37, 0x38, 0x33, 0x41, 0x2d, 0x35, 0x46, 0x44, 0x36, 0x2d, 0x34, 0x39, 0x35, 0x45, 0x2d, 0x39, 0x43, 0x46, 0x34, 0x2d, 0x31, 0x38, 0x43, 0x33, 0x37, 0x41, 0x35, 0x41, 0x39, 0x39, 0x45, 0x46, 0x7d, 0x0d, 0x0a, 0x4d, 0x61, 0x78, 0x2d, 0x46, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x73, 0x3a, 0x20, 0x30, 0x0d, 0x0a, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x54, 0x79, 0x70, 0x65, 0x3a, 0x20, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x78, 0x2d, 0x6d, 0x73, 0x6e, 0x6d, 0x73, 0x67, 0x72, 0x2d, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x72, 0x65, 0x71, 0x62, 0x6f, 0x64, 0x79, 0x0d, 0x0a, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x3a, 0x20, 0x31, 0x30, 0x35, 0x0d, 0x0a, 0x0d, 0x0a, 0x45, 0x55, 0x46, 0x2d, 0x47, 0x55, 0x49, 0x44, 0x3a, 0x20, 0x7b, 0x34, 0x31, 0x44, 0x33, 0x45, 0x37, 0x34, 0x45, 0x2d, 0x30, 0x34, 0x41, 0x32, 0x2d, 0x34, 0x42, 0x33, 0x37, 0x2d, 0x39, 0x36, 0x46, 0x38, 0x2d, 0x30, 0x38, 0x41, 0x43, 0x44, 0x42, 0x36, 0x31, 0x30, 0x38, 0x37, 0x34, 0x7d, 0x0d, 0x0a, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x49, 0x44, 0x3a, 0x20, 0x33, 0x33, 0x38, 0x39, 0x31, 0x33, 0x33, 0x38, 0x33, 0x38, 0x0d, 0x0a, 0x41, 0x70, 0x70, 0x49, 0x44, 0x3a, 0x20, 0x33, 0x35, 0x0d, 0x0a, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x46, 0x6c, 0x61, 0x67, 0x73, 0x3a, 0x20, 0x31, 0x36, 0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x00, 0x00, 0x00];

        //     let msg_as_str = unsafe {from_utf8_unchecked(&msg_command)}.to_owned();
        //     info!("MSG command: {}", &msg_as_str);

        //     let commands = MSNPCommandParser::parse_message(&msg_as_str);
        //     let command = commands.get(0).unwrap();

        //     info!("MSG command payload: {}", command.payload.as_str());

        //     let payload = MsgPayload::from_str(command.payload.as_str()).unwrap();

        //     if let Ok(p2p_packet) = P2PTransportPacket::from_str(&payload.body){

        //         if let Some(request_p2p_payload) = &p2p_packet.payload {
        //             if let Ok(slp_payload) = request_p2p_payload.get_payload_as_slp() {
        //                 let slp_response = SlpPayloadFactory::get_200_ok(&slp_payload);

        //                 let slp_response_serialized = slp_response.to_string().into_bytes();
        //                 let slp_response_length = slp_response_serialized.len();


        //                 let p2p_payload = P2PPayload{ header_length: 0, tf_combination: request_p2p_payload.tf_combination.clone(), package_number: request_p2p_payload.package_number.clone(), session_id: request_p2p_payload.session_id.clone(), tlvs: Vec::new(), payload: slp_response_serialized };
        //                 let mut p2p_transport_response = P2PTransportPacket { header_length: 0, op_code: 0, payload_length: 0, sequence_number: p2p_packet.get_next_squence_number(), tlvs: Vec::new(), payload: Some(p2p_payload)};
        //                 if p2p_packet.is_syn() {
        //                     info!("IS SYN");
        //                     let client_info_tlv = p2p_packet.get_client_info_tlv().unwrap();
        //                     p2p_transport_response.set_syn(client_info_tlv.clone());
        //                 }

        //                 if p2p_packet.is_rak() {
        //                     info!("IS RAK");
        //                     let mut rng = rand::thread_rng();

        //                     let next_seq_number = p2p_packet.get_next_ack_sequence_number().unwrap_or(rng.gen::<u32>());
        //                     p2p_transport_response.set_ack(next_seq_number);
        //                 }

        //                 let source = MSNUser::from_mpop_addr_string(payload.get_header(&String::from("P2P-Dest")).unwrap().to_owned()).unwrap();
        //                 let msg_response = MsgPayloadFactory::get_p2p(&source, &MSNUser::from_mpop_addr_string(payload.get_header(&String::from("P2P-Src")).unwrap().to_owned()).unwrap(), &p2p_transport_response);
        //                 let serialized_response = msg_response.serialize();


        //                 let msg = MsgPayload::from_str(serialized_response.as_str()).unwrap();
        //                 info!("msg payload payload: {}", msg.body.as_str());
        //                 let p2p_transport_packet = P2PTransportPacket::from_str(msg.body.as_str()).unwrap();
        //                 let p2p_transport_packet_serialized = p2p_transport_packet.to_string();

        //                 info!("msg payload payload serialize test: {}", &p2p_transport_packet_serialized);

        //                 assert_eq!(p2p_transport_packet.tlvs.len(), 2);
        //                 assert!(p2p_transport_packet.get_ack_tlv().is_some());
        //                 assert!(p2p_transport_packet.get_client_info_tlv().is_some());

        //                 assert_eq!(msg.body.as_bytes(), p2p_transport_packet_serialized.as_bytes());



        //                 let original_p2p_payload = &p2p_transport_packet.payload.unwrap();
        //                 let p2p_payload_serialized = original_p2p_payload.to_string();
        //                 let p2p_payload_deserialized = P2PPayload::deserialize(p2p_payload_serialized.as_bytes(), p2p_transport_packet.payload_length).unwrap();

        //                 assert_eq!(p2p_payload_deserialized.header_length, original_p2p_payload.header_length);
        //                 assert_eq!(p2p_payload_deserialized.tf_combination, original_p2p_payload.tf_combination);

        //                 let slp_payload = original_p2p_payload.get_payload_as_slp().unwrap();

        //                 info!("slp payload: {}", slp_payload);










        //                 let test = 0;
        //             } else {
        //                 info!("P2P: Message body was not a SLP message: {}", &p2p_packet);
        //             }
        //         }

        //     } else {
        //         info!("P2P: Transport packet deserialization failed: {}", &payload.body);

        //     }
        // }
    }

    #[test]
    #[allow(rustc::invalid_from_utf8_unchecked)]
     fn test_theres_no_payload_here() {
        let mut parser = RawCommandParser::new();

        let msg_command: [u8;2048] = [77, 83, 71, 32, 50, 52, 50, 32, 68, 32, 50, 49, 57, 13, 10, 77, 73, 77, 69, 45, 86, 101, 114, 115, 105, 111, 110, 58, 32, 49, 46, 48, 13, 10, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 32, 97, 112, 112, 108, 105, 99, 97, 116, 105, 111, 110, 47, 120, 45, 109, 115, 110, 109, 115, 103, 114, 112, 50, 112, 13, 10, 80, 50, 80, 45, 68, 101, 115, 116, 58, 32, 97, 101, 111, 110, 116, 101, 115, 116, 51, 64, 115, 104, 108, 46, 108, 111, 99, 97, 108, 59, 123, 55, 55, 99, 52, 54, 97, 56, 102, 45, 51, 51, 97, 51, 45, 53, 50, 56, 50, 45, 57, 97, 53, 100, 45, 57, 48, 53, 101, 99, 100, 51, 101, 98, 48, 54, 57, 125, 13, 10, 80, 50, 80, 45, 83, 114, 99, 58, 32, 97, 101, 111, 110, 116, 101, 115, 116, 64, 115, 104, 108, 46, 108, 111, 99, 97, 108, 59, 123, 102, 53, 50, 57, 55, 51, 98, 54, 45, 99, 57, 50, 54, 45, 52, 98, 97, 100, 45, 57, 98, 97, 56, 45, 55, 99, 49, 101, 56, 52, 48, 101, 52, 97, 98, 48, 125, 13, 10, 13, 10, 16, 0, 0, 0, 47, 129, 42, 25, 2, 4, 143, 231, 143, 193, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

        let msg_as_str = unsafe {from_utf8_unchecked(&msg_command)}.to_owned();
        info!("MSG command: {}", &msg_as_str);

        let commands = parser.parse_message(msg_as_str.as_str());
        let temp = commands.unwrap();

        let command = temp.get(0).unwrap();


        info!("MSG command payload: {}", command.payload.as_str());

        let msg = MsgPayload::from_str(command.payload.as_str()).unwrap();
        info!("msg payload payload: {}", msg.body.as_str());
        let p2p_transport_packet = P2PTransportPacket::from_str(msg.body.as_str()).unwrap();

    }



         */



}