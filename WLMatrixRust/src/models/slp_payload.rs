use std::{collections::HashMap, str::{FromStr, from_utf8, from_utf8_unchecked}, fmt::Display};

use byteorder::{BigEndian, ByteOrder};

use super::errors::Errors;

pub struct SlpPayload {

    pub first_line: String,
    pub headers: HashMap<String, String>,
    pub body: HashMap<String, String>
}

impl SlpPayload {
    pub fn new() -> Self {
        return SlpPayload{ first_line: String::new(), headers: HashMap::new(), body: HashMap::new()};
    }

    pub fn add_header(&mut self, name: String, value: String){
        self.headers.insert(name, value);
    }

    pub fn get_header(&self, name: &String) -> Option<&String> {
        return self.headers.get(name);
    }

    pub fn add_body_property(&mut self, name: String, value: String){
        self.body.insert(name, value);
    }

    pub fn get_body_property(&self, name: &String) -> Option<&String> {
        return self.body.get(name);
    }
}

impl FromStr for SlpPayload {
    type Err = Errors;

    fn from_str(s: &str) -> Result<Self, Self::Err> {

        if let Some((headers, body)) = s.split_once("\r\n\r\n") {
            let mut out = SlpPayload::new();
            let headers_split: Vec<&str> = headers.split("\r\n").collect();

            out.first_line = headers_split.get(0).ok_or(Errors::PayloadDeserializeError)?.to_string();

            for i in 1..headers_split.len() {
                let current = headers_split.get(i).unwrap().to_string();

                if let Some((name, value)) =  current.split_once(":"){
                    out.add_header(name.trim().to_string(), value.trim().to_string());
                }
            }

            let body_split: Vec<&str> = body.split("\r\n").collect();
            for i in 0..body_split.len() {
                let current = body_split.get(i).unwrap().to_string();
                if let Some((name, value)) =  current.split_once(":"){
                    out.add_body_property(name.trim().to_string(), value.trim().to_string());
                }
            }

            return Ok(out);
        }
       return Err(Errors::PayloadDeserializeError);
    }
}

impl TryFrom<&Vec<u8>> for SlpPayload {
    type Error = Errors;

    fn try_from(value: &Vec<u8>) -> Result<Self, Self::Error> {
        let str = from_utf8(value)?;
        return SlpPayload::from_str(str);
    }
}

impl Display for SlpPayload {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {

        let mut out = self.first_line.clone();
        out.push_str("\r\n");

        let mut body = String::new();
        for (key, value) in &self.body {
            body.push_str(format!("{key}: {value}\r\n", key=&key, value=&value).as_str());
        }

        
        let mut headers = String::new();

        headers.push_str(format!("Content-Length: {value}\r\n", value=body.len()).as_str());
        for (key, value) in &self.headers {
            headers.push_str(format!("{key}: {value}\r\n", key=&key, value=&value).as_str());
        }

        out.push_str(headers.as_str());
        out.push_str("\r\n");
        out.push_str(body.as_str());
        out.push_str("\r\n");
        return write!(f, "{}", out);
    }
}


/* P2PHeaderV2 */
/* For the official client to use P2PV2 headers, firstly, our fake client must have the P2PV2 Extended Capability 
AND our fake client must be MPOP enabled. (which means adding endpoint data in NLN UBX payload AND making join the endpoint in switchboards. */
pub struct P2PTransportPacket {

    pub header_length: usize,
    pub op_code : u8,
    pub payload_length: usize,
    pub sequence_number: u32,
    pub tlvs: Vec<TLV>,
    pub payload: Option<P2PPayload>
}

impl P2PTransportPacket {

    pub fn get_next_squence_number(&self) -> u32 {
        return self.sequence_number + self.payload_length as u32;
    }
}

impl FromStr for P2PTransportPacket {
    type Err = Errors;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let bytes = s.as_bytes().to_owned();
        let header_length = bytes.get(0).unwrap_or(&0).to_owned() as usize;
        let op_code = bytes.get(1).unwrap_or(&0).to_owned();
        let payload_length = BigEndian::read_u16(&bytes[2..4]) as usize;
        let sequence_number = BigEndian::read_u32(&bytes[4..8]);
        let tlvs_length = header_length - 8;
        let mut tlvs: Vec<TLV> = Vec::new();

        if tlvs_length > 0 {
            let mut tlvs_treated_count = 0;
            let tlvs_bytes = &bytes[8..8+tlvs_length];
            while tlvs_treated_count != tlvs_length - 2 {
                let start_index = tlvs_treated_count;
                let value_type = tlvs_bytes.get(start_index).unwrap().to_owned();
                let length = tlvs_bytes.get(start_index+1).unwrap().to_owned() as usize;
                let value = tlvs_bytes[start_index+2..2 + length].to_owned();
                tlvs.push(TLV{ length, value_type, value });
                tlvs_treated_count += length + 2;
            }
        }

        let mut payload = None;
        if payload_length > 0 {
            payload = Some(P2PPayload::deserialize(&bytes[8+tlvs_length..bytes.len()], payload_length)?);
        }


        let stop = true;
        return Ok(P2PTransportPacket{ header_length, op_code, payload_length, sequence_number, tlvs, payload });

    }
}

impl Display for P2PTransportPacket {
    
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut out: Vec<u8> = Vec::new();
        out.push(self.op_code.clone());

        let mut buffer : [u8;2] = [0,0];
        BigEndian::write_u16(&mut buffer, self.payload_length as u16);
        out.append(&mut buffer.to_vec());

        let mut buffer : [u8;4] = [0,0,0,0];
        BigEndian::write_u32(&mut buffer, self.sequence_number);
        out.append(&mut buffer.to_vec());

        for tlv in &self.tlvs {
            let mut tlv_serialized : Vec<u8> = tlv.as_vec();
            out.append(&mut tlv_serialized);
        }

        if !self.tlvs.is_empty() {
            let padding : [u8;4] = [0,0,0,0];
            out.append(&mut padding.to_vec());
        }

        out.insert(0, (out.len() + 1) as u8);
        let mut out_str = unsafe { from_utf8_unchecked(&out) }.to_string();

        if let Some(payload) = &self.payload {
            out_str.push_str(payload.to_string().as_str());
        }
        return write!(f, "{}", out_str);
    }
}

pub struct P2PPayload {

    pub header_length: usize,
    pub tf_combination : u8,
    pub package_number: u16,
    pub session_id: u32,
    pub tlvs: Vec<TLV>,
    pub payload: Vec<u8>
}

impl P2PPayload {

    pub fn deserialize(bytes: &[u8], payload_length: usize) -> Result<Self, Errors> {
        let header_length = bytes.get(0).unwrap_or(&0).to_owned() as usize;
        let tf_combination = bytes.get(1).unwrap_or(&0).to_owned();
        let package_number = BigEndian::read_u16(&bytes[2..4]);
        let session_id = BigEndian::read_u32(&bytes[4..8]);
        let tlvs_length = header_length - 8;
        let mut tlvs: Vec<TLV> = Vec::new();
        if tlvs_length > 0 {
            let mut tlvs_treated_count = 0;
            let tlvs_bytes = &bytes[8..8+tlvs_length];
            while tlvs_treated_count != tlvs_length - 2 {
                let start_index = tlvs_treated_count;
                let value_type = tlvs_bytes.get(start_index).unwrap().to_owned();
                let length = tlvs_bytes.get(start_index+1).unwrap().to_owned() as usize;
                let value = tlvs_bytes[start_index+2..2 + length].to_owned();
                tlvs.push(TLV{ length, value_type, value });
                tlvs_treated_count += length + 2;
            }
        }

        let payload = bytes[8+tlvs_length..payload_length].to_owned();
        return Ok(P2PPayload{ header_length, tf_combination, package_number, session_id, tlvs, payload });
    }

    pub fn get_payload_as_slp(&self) -> Result<SlpPayload, Errors> {
        return SlpPayload::try_from(&self.payload);
    }
 
}

impl Display for P2PPayload {

    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut out: Vec<u8> = Vec::new();

        out.push(self.tf_combination.clone());

        let mut buffer : [u8;2] = [0,0];
        BigEndian::write_u16(&mut buffer, self.package_number);
        out.append(&mut buffer.to_vec());

        let mut buffer : [u8;4] = [0,0,0,0];
        BigEndian::write_u32(&mut buffer, self.session_id);
        out.append(&mut buffer.to_vec());

        for tlv in &self.tlvs {
            let mut tlv_serialized : Vec<u8> = tlv.as_vec();
            out.append(&mut tlv_serialized);
        }

        if !self.tlvs.is_empty() {
            let padding : [u8;4] = [0,0,0,0];
            out.append(&mut padding.to_vec());
        }

        out.insert(0, (out.len() + 1) as u8);

        out.append(&mut self.payload.clone());

        let padding : [u8;3] = [0,0,0];
        out.append(&mut padding.to_vec());

        let out_str = unsafe { from_utf8_unchecked(&out) };
        return write!(f, "{}", out_str);

    }
}

pub struct TLV {
    length: usize,
    value_type: u8,
    value: Vec<u8>
}

impl TLV {

    pub fn new(value_type: u8, length: usize, value: Vec<u8>) -> Self {
        return TLV{length, value_type, value};
    }

    pub fn empty() -> Self {
        return TLV::new(0, 0, Vec::new());
    }

    fn as_vec(&self) -> Vec<u8> {
        let mut out = Vec::new();
        out.push(self.value_type.clone());
        out.push(self.length.clone() as u8);
        out.append(&mut self.value.clone());

        return out;
    }

}

pub enum ValueType {
    SizeOfUntransferData,
    AckSequenceNumber,
    ClientPeerInfo,
    NakSequenceNumber 
}



pub enum OperationCode {
    None = 0x0,
    RequestForAck = 0x01,
    Ack = 0x02,
    InitSession = 0x03
}

pub mod factories {
    use byteorder::{BigEndian, ByteOrder, LittleEndian};

    use crate::models::uuid::UUID;

    use super::{TLV, P2PPayload, SlpPayload};


    pub struct SlpPayloadFactory;

    impl SlpPayloadFactory {

        pub fn get_200_ok(invite: &SlpPayload) -> SlpPayload {
            let mut out = SlpPayload::new();
            out.first_line = String::from("MSNSLP/1.0 200 OK");

            
            out.add_header(String::from("To"), invite.get_header(&String::from("From")).unwrap().to_owned());
            out.add_header(String::from("From"), invite.get_header(&String::from("To")).unwrap().to_owned());
            out.add_header(String::from("Via"), invite.get_header(&String::from("Via")).unwrap().to_owned());

            let cseq = invite.headers.get("CSeq").unwrap().parse::<i32>().unwrap() + 1;
            out.add_header(String::from("CSeq"), cseq.to_string());
            out.add_header(String::from("Call-ID"), invite.get_header(&String::from("Call-ID")).unwrap().to_owned());
            out.add_header(String::from("Max-Forwards"), String::from("0"));
            out.add_header(String::from("Content-Type"), String::from("application/x-msnmsgr-transreqbody"));

            if let Some(session_id) = invite.get_body_property(&String::from("SessionID")){
                out.add_body_property(String::from("SessionID"), session_id.to_owned());
            }

            out.add_body_property(String::from("Conn-Type"), String::from("Firewall"));
            out.add_body_property(String::from("ICF"), String::from("true"));
            out.add_body_property(String::from("Bridge"), String::from("SBBridge"));
            out.add_body_property(String::from("Listening"), String::from("true"));
            out.add_body_property(String::from("Nonce"), format!("{{{}}}", UUID::new().to_string()));

            return out;
        }
    
    }


    struct P2PPayloadFactory;

    impl P2PPayloadFactory {

    }

    struct TLVFactory;

    impl TLVFactory {

        pub fn get_ack(sequence_number: u32) -> TLV {
            let mut buffer: [u8;4] = [0,0,0,0];
            BigEndian::write_u32(&mut buffer, sequence_number);
            return TLV::new(0x02, 0x04, buffer.to_vec());
        }

        pub fn get_nak(sequence_number: u32) -> TLV {
            let mut buffer: [u8;4] = [0,0,0,0];
            BigEndian::write_u32(&mut buffer, sequence_number);
            return TLV::new(0x03, 0x04, buffer.to_vec());
        }

        pub fn get_untransfered_data_size(sequence_number: u64) -> TLV {
            let mut buffer: [u8;8] = [0,0,0,0,0,0,0,0];
            BigEndian::write_u64(&mut buffer, sequence_number);
            return TLV::new(0x01, 0x08, buffer.to_vec());
        }

        pub fn get_client_peer_info() -> TLV {

            let protocol_version: u32 = 0x0200;
            let impl_idu: u32 = 0x0000;
            let version: u32 = 0x0e00;

            let reserved_bytes: u32 = 0x2d76;
            let capabilities: u64 = 0x0000010f;

            let mut value: Vec<u8> = Vec::new();

            let mut buffer: [u8;4] = [0,0,0,0];
            LittleEndian::write_u32(&mut buffer, protocol_version);
            value.append(&mut buffer.to_vec());

            let mut buffer: [u8;4] = [0,0,0,0];
            LittleEndian::write_u32(&mut buffer, impl_idu);
            value.append(&mut buffer.to_vec());
            
            let mut buffer: [u8;4] = [0,0,0,0];
            LittleEndian::write_u32(&mut buffer, version);
            value.append(&mut buffer.to_vec());

            let mut buffer: [u8;4] = [0,0,0,0];
            LittleEndian::write_u32(&mut buffer, reserved_bytes);
            value.append(&mut buffer.to_vec());

            let mut buffer: [u8;8] = [0,0,0,0,0,0,0,0];
            LittleEndian::write_u64(&mut buffer, capabilities);
            value.append(&mut buffer.to_vec());            

            return TLV::new(0x01, 0xc, value);
        }


    }

}

#[cfg(test)]
mod tests {
    use std::str::{from_utf8_unchecked, FromStr};

    use log::info;

    use crate::models::slp_payload::P2PPayload;
    use crate::{models::msg_payload::MsgPayload, sockets::msnp_command::MSNPCommandParser};

    use super::{P2PTransportPacket, SlpPayload};

    use super::factories::SlpPayloadFactory;

    #[test]
    fn test_deserialize_msg_command_containing_slp_payload() {
        env_logger::init_from_env(env_logger::Env::new().default_filter_or("info"));

        //let msg : [u8;672] = [0x18, 0x03, 0x02, 0xe2, 0x6a, 0x23, 0x43, 0xff, 0x01, 0x0c, 0x00 ,0x02, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x0f, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08 ,0x00, 0x00, 0x00, 0x00, 0x00, 0x49, 0x4e, 0x56, 0x49, 0x54, 0x45, 0x20, 0x4d, 0x53 ,0x53, 0x47, 0x52, 0x3a, 0x77, 0x70, 0x30, 0x31, 0x40, 0x6c, 0x69, 0x76, 0x65, 0x2e ,0x3b, 0x7b, 0x64, 0x39, 0x66, 0x64, 0x31, 0x36, 0x31, 0x62, 0x2d, 0x64, 0x34, 0x64 ,0x34, 0x63, 0x61, 0x37, 0x2d, 0x38, 0x61, 0x36, 0x38, 0x2d, 0x63, 0x37, 0x30, 0x66 ,0x33, 0x39, 0x61, 0x33, 0x33, 0x30, 0x7d, 0x20, 0x4d, 0x53, 0x4e, 0x53, 0x4c, 0x50 ,0x2e, 0x30, 0x0d, 0x0a, 0x54, 0x6f, 0x3a, 0x20, 0x3c, 0x6d, 0x73, 0x6e, 0x6d, 0x73 ,0x3a, 0x77, 0x70, 0x30, 0x31, 0x40, 0x6c, 0x69, 0x76, 0x65, 0x2e, 0x63, 0x6e, 0x3b ,0x39, 0x66, 0x64, 0x31, 0x36, 0x31, 0x62, 0x2d, 0x64, 0x34, 0x64, 0x38, 0x2d, 0x34 ,0x37, 0x2d, 0x38, 0x61, 0x36, 0x38, 0x2d, 0x63, 0x37, 0x30, 0x66, 0x65, 0x62, 0x33 ,0x33, 0x33, 0x30, 0x7d, 0x3e, 0x0d, 0x0a, 0x46, 0x72, 0x6f, 0x6d, 0x3a, 0x20, 0x3c ,0x6e, 0x6d, 0x73, 0x67, 0x72, 0x3a, 0x66, 0x72, 0x65, 0x65, 0x7a, 0x69, 0x6e, 0x67 ,0x66, 0x74, 0x40, 0x68, 0x6f, 0x74, 0x6d, 0x61, 0x69, 0x6c, 0x2e, 0x63, 0x6f, 0x6d ,0x37, 0x65, 0x64, 0x66, 0x39, 0x64, 0x32, 0x34, 0x2d, 0x37, 0x65, 0x39, 0x38, 0x2d ,0x32, 0x30, 0x2d, 0x39, 0x66, 0x30, 0x35, 0x2d, 0x37, 0x34, 0x63, 0x33, 0x61, 0x62 ,0x30, 0x37, 0x37, 0x30, 0x7d, 0x3e, 0x0d, 0x0a, 0x56, 0x69, 0x61, 0x3a, 0x20, 0x4d ,0x53, 0x4c, 0x50, 0x2f, 0x31, 0x2e, 0x30, 0x2f, 0x54, 0x4c, 0x50, 0x20, 0x3b, 0x62 ,0x6e, 0x63, 0x68, 0x3d, 0x7b, 0x37, 0x42, 0x41, 0x44, 0x41, 0x35, 0x35, 0x39, 0x2d ,0x45, 0x32, 0x2d, 0x34, 0x41, 0x46, 0x45, 0x2d, 0x41, 0x35, 0x32, 0x39, 0x2d, 0x39 ,0x34, 0x41, 0x39, 0x36, 0x34, 0x37, 0x46, 0x44, 0x35, 0x7d, 0x0d, 0x0a, 0x43, 0x53 ,0x3a, 0x20, 0x30, 0x20, 0x0d, 0x0a, 0x43, 0x61, 0x6c, 0x6c, 0x2d, 0x49, 0x44, 0x3a ,0x42, 0x30, 0x42, 0x34, 0x31, 0x41, 0x30, 0x41, 0x2d, 0x35, 0x32, 0x35, 0x32, 0x2d ,0x43, 0x44, 0x2d, 0x42, 0x46, 0x38, 0x31, 0x2d, 0x30, 0x39, 0x36, 0x37, 0x45, 0x39 ,0x38, 0x36, 0x34, 0x34, 0x7d, 0x0d, 0x0a, 0x4d, 0x61, 0x78, 0x2d, 0x46, 0x6f, 0x72 ,0x72, 0x64, 0x73, 0x3a, 0x20, 0x30, 0x0d, 0x0a, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e ,0x54, 0x79, 0x70, 0x65, 0x3a, 0x20, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74 ,0x6e, 0x2f, 0x78, 0x2d, 0x6d, 0x73, 0x6e, 0x6d, 0x73, 0x67, 0x72, 0x2d, 0x73, 0x65 ,0x69, 0x6f, 0x6e, 0x72, 0x65, 0x71, 0x62, 0x6f, 0x64, 0x79, 0x0d, 0x0a, 0x43, 0x6f ,0x65, 0x6e, 0x74, 0x2d, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x3a, 0x20, 0x32, 0x38 ,0x0a, 0x0d, 0x0a, 0x45, 0x55, 0x46, 0x2d, 0x47, 0x55, 0x49, 0x44, 0x3a, 0x20, 0x7b ,0x32, 0x36, 0x38, 0x45, 0x45, 0x43, 0x2d, 0x46, 0x45, 0x43, 0x35, 0x2d, 0x34, 0x39 ,0x2d, 0x39, 0x35, 0x43, 0x33, 0x2d, 0x46, 0x31, 0x32, 0x36, 0x36, 0x39, 0x36, 0x42 ,0x46, 0x36, 0x7d, 0x0d, 0x0a, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x49, 0x44 ,0x32, 0x36, 0x32, 0x35, 0x33, 0x32, 0x39, 0x32, 0x34, 0x37, 0x0d, 0x0a, 0x41, 0x70 ,0x44, 0x3a, 0x20, 0x31, 0x32, 0x0d, 0x0a, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74 ,0x61, 0x67, 0x73, 0x3a, 0x20, 0x31, 0x38, 0x0d, 0x0a, 0x43, 0x6f, 0x6e, 0x74, 0x65 ,0x3a, 0x20, 0x50, 0x47, 0x31, 0x7a, 0x62, 0x6d, 0x39, 0x69, 0x61, 0x69, 0x42, 0x44 ,0x56, 0x68, 0x64, 0x47, 0x39, 0x79, 0x50, 0x53, 0x4a, 0x33, 0x63, 0x44, 0x41, 0x78 ,0x78, 0x70, 0x64, 0x6d, 0x55, 0x75, 0x59, 0x32, 0x34, 0x69, 0x49, 0x46, 0x52, 0x35 ,0x55, 0x39, 0x49, 0x6a, 0x4d, 0x69, 0x49, 0x46, 0x4e, 0x49, 0x51, 0x54, 0x46, 0x45 ,0x4a, 0x5a, 0x54, 0x69, 0x74, 0x72, 0x4e, 0x48, 0x70, 0x4c, 0x4b, 0x30, 0x6c, 0x6d ,0x64, 0x30, 0x52, 0x31, 0x68, 0x79, 0x54, 0x48, 0x49, 0x78, 0x64, 0x56, 0x4e, 0x61 ,0x6c, 0x5a, 0x52, 0x47, 0x73, 0x39, 0x49, 0x69, 0x42, 0x54, 0x61, 0x58, 0x70, 0x6c ,0x49, 0x78, 0x4e, 0x7a, 0x41, 0x35, 0x4e, 0x53, 0x49, 0x67, 0x54, 0x47, 0x39, 0x6a ,0x52, 0x70, 0x62, 0x32, 0x34, 0x39, 0x49, 0x6a, 0x41, 0x69, 0x49, 0x45, 0x5a, 0x79 ,0x56, 0x75, 0x5a, 0x47, 0x78, 0x35, 0x50, 0x53, 0x4a, 0x4e, 0x55, 0x55, 0x46, 0x42 ,0x45, 0x39, 0x50, 0x53, 0x49, 0x76, 0x50, 0x67, 0x41, 0x3d, 0x0d, 0x0a, 0x0d, 0x0a ,0x00, 0x00, 0x00];
        //let msg_command : [u8;626] = [0x4d, 0x53, 0x47, 0x20, 0x38, 0x35, 0x20, 0x44, 0x20, 0x36, 0x31, 0x34, 0x0d, 0x0a, 0x4d, 0x49, 0x4d, 0x45, 0x2d, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x3a, 0x20, 0x31, 0x2e, 0x30, 0x0d, 0x0a, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x54, 0x79, 0x70, 0x65, 0x3a, 0x20, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x78, 0x2d, 0x6d, 0x73, 0x6e, 0x6d, 0x73, 0x67, 0x72, 0x70, 0x32, 0x70, 0x0d, 0x0a, 0x50, 0x32, 0x50, 0x2d, 0x44, 0x65, 0x73, 0x74, 0x3a, 0x20, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x33, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x0d, 0x0a, 0x50, 0x32, 0x50, 0x2d, 0x53, 0x72, 0x63, 0x3a, 0x20, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x00, 0x00, 0x00, 0xe3, 0xff, 0x3b, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb9, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb9, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xca, 0x3d, 0x5b, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49, 0x4e, 0x56, 0x49, 0x54, 0x45, 0x20, 0x4d, 0x53, 0x4e, 0x4d, 0x53, 0x47, 0x52, 0x3a, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x33, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x4d, 0x53, 0x4e, 0x53, 0x4c, 0x50, 0x2f, 0x31, 0x2e, 0x30, 0x0d, 0x0a, 0x54, 0x6f, 0x3a, 0x20, 0x3c, 0x6d, 0x73, 0x6e, 0x6d, 0x73, 0x67, 0x72, 0x3a, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x33, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x3e, 0x0d, 0x0a, 0x46, 0x72, 0x6f, 0x6d, 0x3a, 0x20, 0x3c, 0x6d, 0x73, 0x6e, 0x6d, 0x73, 0x67, 0x72, 0x3a, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x3e, 0x0d, 0x0a, 0x56, 0x69, 0x61, 0x3a, 0x20, 0x4d, 0x53, 0x4e, 0x53, 0x4c, 0x50, 0x2f, 0x31, 0x2e, 0x30, 0x2f, 0x54, 0x4c, 0x50, 0x20, 0x3b, 0x62, 0x72, 0x61, 0x6e, 0x63, 0x68, 0x3d, 0x7b, 0x43, 0x43, 0x37, 0x42, 0x30, 0x32, 0x46, 0x42, 0x2d, 0x39, 0x30, 0x46, 0x46, 0x2d, 0x34, 0x45, 0x42, 0x39, 0x2d, 0x42, 0x43, 0x37, 0x33, 0x2d, 0x38, 0x41, 0x45, 0x39, 0x34, 0x32, 0x42, 0x31, 0x38, 0x42, 0x41, 0x31, 0x7d, 0x0d, 0x0a, 0x43, 0x53, 0x65, 0x71, 0x3a, 0x20, 0x30, 0x20, 0x0d, 0x0a, 0x43, 0x61, 0x6c, 0x6c, 0x2d, 0x49, 0x44, 0x3a, 0x20, 0x7b, 0x43, 0x36, 0x38, 0x38, 0x43, 0x38, 0x41, 0x42, 0x2d, 0x44, 0x42, 0x38, 0x36, 0x2d, 0x34, 0x34, 0x34, 0x31, 0x2d, 0x38, 0x41, 0x45, 0x33, 0x2d, 0x41, 0x32, 0x43, 0x31, 0x35, 0x42, 0x45, 0x43, 0x30, 0x30, 0x32, 0x37, 0x7d, 0x0d, 0x0a, 0x4d, 0x61, 0x78, 0x2d, 0x46, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x73, 0x3a, 0x20, 0x30, 0x0d, 0x0a, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x54, 0x79, 0x70, 0x65, 0x3a, 0x20, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x78, 0x2d, 0x6d, 0x73, 0x6e, 0x6d, 0x73, 0x67, 0x72, 0x2d, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x72, 0x65, 0x71, 0x62, 0x6f, 0x64, 0x79, 0x0d, 0x0a, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x3a, 0x20, 0x31, 0x30, 0x34, 0x0d, 0x0a, 0x0d, 0x0a, 0x45, 0x55, 0x46, 0x2d, 0x47, 0x55, 0x49, 0x44, 0x3a, 0x20, 0x7b, 0x34, 0x31, 0x44, 0x33, 0x45, 0x37, 0x34, 0x45, 0x2d, 0x30, 0x34, 0x41, 0x32, 0x2d, 0x34, 0x42, 0x33, 0x37, 0x2d, 0x39, 0x36, 0x46, 0x38, 0x2d, 0x30, 0x38, 0x41, 0x43, 0x44, 0x42, 0x36, 0x31, 0x30, 0x38, 0x37, 0x34, 0x7d, 0x0d, 0x0a, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x49, 0x44, 0x3a, 0x20, 0x39, 0x36, 0x32, 0x32, 0x38, 0x30, 0x37, 0x35, 0x32, 0x0d, 0x0a, 0x53, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x53, 0x74, 0x61, 0x74, 0x65, 0x3a, 0x20, 0x30, 0x0d, 0x0a, 0x41, 0x70, 0x70, 0x49, 0x44, 0x3a, 0x20, 0x33, 0x35, 0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x00, 0x00];
        //let msg_command : [u8;626] = [0x4d, 0x53, 0x47, 0x20, 0x35, 0x20, 0x44, 0x20, 0x36, 0x31, 0x35, 0x0d, 0x0a, 0x4d, 0x49, 0x4d, 0x45, 0x2d, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x3a, 0x20, 0x31, 0x2e, 0x30, 0x0d, 0x0a, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x54, 0x79, 0x70, 0x65, 0x3a, 0x20, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x78, 0x2d, 0x6d, 0x73, 0x6e, 0x6d, 0x73, 0x67, 0x72, 0x70, 0x32, 0x70, 0x0d, 0x0a, 0x50, 0x32, 0x50, 0x2d, 0x44, 0x65, 0x73, 0x74, 0x3a, 0x20, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x33, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x0d, 0x0a, 0x50, 0x32, 0x50, 0x2d, 0x53, 0x72, 0x63, 0x3a, 0x20, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x6e, 0xdb, 0x43, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xba, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xba, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x8c, 0xdb, 0x43, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49, 0x4e, 0x56, 0x49, 0x54, 0x45, 0x20, 0x4d, 0x53, 0x4e, 0x4d, 0x53, 0x47, 0x52, 0x3a, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x33, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x4d, 0x53, 0x4e, 0x53, 0x4c, 0x50, 0x2f, 0x31, 0x2e, 0x30, 0x0d, 0x0a, 0x54, 0x6f, 0x3a, 0x20, 0x3c, 0x6d, 0x73, 0x6e, 0x6d, 0x73, 0x67, 0x72, 0x3a, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x33, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x3e, 0x0d, 0x0a, 0x46, 0x72, 0x6f, 0x6d, 0x3a, 0x20, 0x3c, 0x6d, 0x73, 0x6e, 0x6d, 0x73, 0x67, 0x72, 0x3a, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x3e, 0x0d, 0x0a, 0x56, 0x69, 0x61, 0x3a, 0x20, 0x4d, 0x53, 0x4e, 0x53, 0x4c, 0x50, 0x2f, 0x31, 0x2e, 0x30, 0x2f, 0x54, 0x4c, 0x50, 0x20, 0x3b, 0x62, 0x72, 0x61, 0x6e, 0x63, 0x68, 0x3d, 0x7b, 0x36, 0x46, 0x43, 0x36, 0x45, 0x31, 0x34, 0x37, 0x2d, 0x45, 0x43, 0x36, 0x31, 0x2d, 0x34, 0x44, 0x42, 0x34, 0x2d, 0x38, 0x39, 0x32, 0x39, 0x2d, 0x33, 0x33, 0x39, 0x38, 0x44, 0x31, 0x37, 0x30, 0x36, 0x46, 0x33, 0x37, 0x7d, 0x0d, 0x0a, 0x43, 0x53, 0x65, 0x71, 0x3a, 0x20, 0x30, 0x20, 0x0d, 0x0a, 0x43, 0x61, 0x6c, 0x6c, 0x2d, 0x49, 0x44, 0x3a, 0x20, 0x7b, 0x38, 0x36, 0x36, 0x39, 0x46, 0x33, 0x30, 0x31, 0x2d, 0x32, 0x45, 0x46, 0x43, 0x2d, 0x34, 0x35, 0x36, 0x44, 0x2d, 0x39, 0x33, 0x41, 0x34, 0x2d, 0x31, 0x31, 0x36, 0x33, 0x39, 0x42, 0x37, 0x34, 0x36, 0x44, 0x42, 0x41, 0x7d, 0x0d, 0x0a, 0x4d, 0x61, 0x78, 0x2d, 0x46, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x73, 0x3a, 0x20, 0x30, 0x0d, 0x0a, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x54, 0x79, 0x70, 0x65, 0x3a, 0x20, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x78, 0x2d, 0x6d, 0x73, 0x6e, 0x6d, 0x73, 0x67, 0x72, 0x2d, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x72, 0x65, 0x71, 0x62, 0x6f, 0x64, 0x79, 0x0d, 0x0a, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x3a, 0x20, 0x31, 0x30, 0x35, 0x0d, 0x0a, 0x0d, 0x0a, 0x45, 0x55, 0x46, 0x2d, 0x47, 0x55, 0x49, 0x44, 0x3a, 0x20, 0x7b, 0x34, 0x31, 0x44, 0x33, 0x45, 0x37, 0x34, 0x45, 0x2d, 0x30, 0x34, 0x41, 0x32, 0x2d, 0x34, 0x42, 0x33, 0x37, 0x2d, 0x39, 0x36, 0x46, 0x38, 0x2d, 0x30, 0x38, 0x41, 0x43, 0x44, 0x42, 0x36, 0x31, 0x30, 0x38, 0x37, 0x34, 0x7d, 0x0d, 0x0a, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x49, 0x44, 0x3a, 0x20, 0x31, 0x30, 0x39, 0x34, 0x39, 0x36, 0x35, 0x36, 0x34, 0x32, 0x0d, 0x0a, 0x53, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x53, 0x74, 0x61, 0x74, 0x65, 0x3a, 0x20, 0x30, 0x0d, 0x0a, 0x41, 0x70, 0x70, 0x49, 0x44, 0x3a, 0x20, 0x33, 0x35, 0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x00, 0x00];
        let msg_command : [u8;1007] = [0x4d, 0x53, 0x47, 0x20, 0x32, 0x36, 0x20, 0x44, 0x20, 0x39, 0x39, 0x34, 0x0d, 0x0a, 0x4d, 0x49, 0x4d, 0x45, 0x2d, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x3a, 0x20, 0x31, 0x2e, 0x30, 0x0d, 0x0a, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x54, 0x79, 0x70, 0x65, 0x3a, 0x20, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x78, 0x2d, 0x6d, 0x73, 0x6e, 0x6d, 0x73, 0x67, 0x72, 0x70, 0x32, 0x70, 0x0d, 0x0a, 0x50, 0x32, 0x50, 0x2d, 0x44, 0x65, 0x73, 0x74, 0x3a, 0x20, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x33, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x3b, 0x7b, 0x37, 0x37, 0x63, 0x34, 0x36, 0x61, 0x38, 0x66, 0x2d, 0x33, 0x33, 0x61, 0x33, 0x2d, 0x35, 0x32, 0x38, 0x32, 0x2d, 0x39, 0x61, 0x35, 0x64, 0x2d, 0x39, 0x30, 0x35, 0x65, 0x63, 0x64, 0x33, 0x65, 0x62, 0x30, 0x36, 0x39, 0x7d, 0x0d, 0x0a, 0x50, 0x32, 0x50, 0x2d, 0x53, 0x72, 0x63, 0x3a, 0x20, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x3b, 0x7b, 0x66, 0x35, 0x32, 0x39, 0x37, 0x33, 0x62, 0x36, 0x2d, 0x63, 0x39, 0x32, 0x36, 0x2d, 0x34, 0x62, 0x61, 0x64, 0x2d, 0x39, 0x62, 0x61, 0x38, 0x2d, 0x37, 0x63, 0x31, 0x65, 0x38, 0x34, 0x30, 0x65, 0x34, 0x61, 0x62, 0x30, 0x7d, 0x0d, 0x0a, 0x0d, 0x0a, 0x08, 0x00, 0x03, 0x0f, 0x32, 0x52, 0xd1, 0xec, 0x08, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x49, 0x4e, 0x56, 0x49, 0x54, 0x45, 0x20, 0x4d, 0x53, 0x4e, 0x4d, 0x53, 0x47, 0x52, 0x3a, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x33, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x3b, 0x7b, 0x37, 0x37, 0x63, 0x34, 0x36, 0x61, 0x38, 0x66, 0x2d, 0x33, 0x33, 0x61, 0x33, 0x2d, 0x35, 0x32, 0x38, 0x32, 0x2d, 0x39, 0x61, 0x35, 0x64, 0x2d, 0x39, 0x30, 0x35, 0x65, 0x63, 0x64, 0x33, 0x65, 0x62, 0x30, 0x36, 0x39, 0x7d, 0x20, 0x4d, 0x53, 0x4e, 0x53, 0x4c, 0x50, 0x2f, 0x31, 0x2e, 0x30, 0x0d, 0x0a, 0x54, 0x6f, 0x3a, 0x20, 0x3c, 0x6d, 0x73, 0x6e, 0x6d, 0x73, 0x67, 0x72, 0x3a, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x33, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x3b, 0x7b, 0x37, 0x37, 0x63, 0x34, 0x36, 0x61, 0x38, 0x66, 0x2d, 0x33, 0x33, 0x61, 0x33, 0x2d, 0x35, 0x32, 0x38, 0x32, 0x2d, 0x39, 0x61, 0x35, 0x64, 0x2d, 0x39, 0x30, 0x35, 0x65, 0x63, 0x64, 0x33, 0x65, 0x62, 0x30, 0x36, 0x39, 0x7d, 0x3e, 0x0d, 0x0a, 0x46, 0x72, 0x6f, 0x6d, 0x3a, 0x20, 0x3c, 0x6d, 0x73, 0x6e, 0x6d, 0x73, 0x67, 0x72, 0x3a, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x3b, 0x7b, 0x66, 0x35, 0x32, 0x39, 0x37, 0x33, 0x62, 0x36, 0x2d, 0x63, 0x39, 0x32, 0x36, 0x2d, 0x34, 0x62, 0x61, 0x64, 0x2d, 0x39, 0x62, 0x61, 0x38, 0x2d, 0x37, 0x63, 0x31, 0x65, 0x38, 0x34, 0x30, 0x65, 0x34, 0x61, 0x62, 0x30, 0x7d, 0x3e, 0x0d, 0x0a, 0x56, 0x69, 0x61, 0x3a, 0x20, 0x4d, 0x53, 0x4e, 0x53, 0x4c, 0x50, 0x2f, 0x31, 0x2e, 0x30, 0x2f, 0x54, 0x4c, 0x50, 0x20, 0x3b, 0x62, 0x72, 0x61, 0x6e, 0x63, 0x68, 0x3d, 0x7b, 0x44, 0x37, 0x36, 0x34, 0x44, 0x32, 0x39, 0x38, 0x2d, 0x33, 0x37, 0x42, 0x38, 0x2d, 0x34, 0x43, 0x38, 0x41, 0x2d, 0x42, 0x39, 0x44, 0x36, 0x2d, 0x45, 0x38, 0x31, 0x31, 0x41, 0x45, 0x44, 0x31, 0x43, 0x39, 0x38, 0x31, 0x7d, 0x0d, 0x0a, 0x43, 0x53, 0x65, 0x71, 0x3a, 0x20, 0x30, 0x20, 0x0d, 0x0a, 0x43, 0x61, 0x6c, 0x6c, 0x2d, 0x49, 0x44, 0x3a, 0x20, 0x7b, 0x30, 0x32, 0x42, 0x42, 0x39, 0x45, 0x41, 0x35, 0x2d, 0x46, 0x30, 0x44, 0x42, 0x2d, 0x34, 0x31, 0x42, 0x46, 0x2d, 0x38, 0x30, 0x45, 0x33, 0x2d, 0x32, 0x39, 0x31, 0x43, 0x42, 0x39, 0x38, 0x46, 0x39, 0x37, 0x39, 0x33, 0x7d, 0x0d, 0x0a, 0x4d, 0x61, 0x78, 0x2d, 0x46, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x73, 0x3a, 0x20, 0x30, 0x0d, 0x0a, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x54, 0x79, 0x70, 0x65, 0x3a, 0x20, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x78, 0x2d, 0x6d, 0x73, 0x6e, 0x6d, 0x73, 0x67, 0x72, 0x2d, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x72, 0x65, 0x71, 0x62, 0x6f, 0x64, 0x79, 0x0d, 0x0a, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x3a, 0x20, 0x33, 0x32, 0x33, 0x0d, 0x0a, 0x0d, 0x0a, 0x4e, 0x65, 0x74, 0x49, 0x44, 0x3a, 0x20, 0x31, 0x30, 0x34, 0x30, 0x32, 0x39, 0x36, 0x31, 0x32, 0x38, 0x0d, 0x0a, 0x43, 0x6f, 0x6e, 0x6e, 0x2d, 0x54, 0x79, 0x70, 0x65, 0x3a, 0x20, 0x46, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x0d, 0x0a, 0x54, 0x43, 0x50, 0x2d, 0x43, 0x6f, 0x6e, 0x6e, 0x2d, 0x54, 0x79, 0x70, 0x65, 0x3a, 0x20, 0x46, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x0d, 0x0a, 0x55, 0x50, 0x6e, 0x50, 0x4e, 0x61, 0x74, 0x3a, 0x20, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x0d, 0x0a, 0x49, 0x43, 0x46, 0x3a, 0x20, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x0d, 0x0a, 0x49, 0x50, 0x76, 0x36, 0x2d, 0x67, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x3a, 0x20, 0x32, 0x61, 0x30, 0x32, 0x3a, 0x61, 0x30, 0x33, 0x66, 0x3a, 0x61, 0x31, 0x33, 0x65, 0x3a, 0x32, 0x36, 0x30, 0x30, 0x3a, 0x38, 0x34, 0x35, 0x36, 0x3a, 0x66, 0x61, 0x37, 0x65, 0x3a, 0x33, 0x30, 0x31, 0x62, 0x3a, 0x63, 0x34, 0x35, 0x34, 0x0d, 0x0a, 0x43, 0x61, 0x70, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x69, 0x65, 0x73, 0x2d, 0x46, 0x6c, 0x61, 0x67, 0x73, 0x3a, 0x20, 0x31, 0x0d, 0x0a, 0x4e, 0x61, 0x74, 0x2d, 0x54, 0x72, 0x61, 0x76, 0x2d, 0x4d, 0x73, 0x67, 0x2d, 0x54, 0x79, 0x70, 0x65, 0x3a, 0x20, 0x57, 0x4c, 0x58, 0x2d, 0x4e, 0x61, 0x74, 0x2d, 0x54, 0x72, 0x61, 0x76, 0x2d, 0x4d, 0x73, 0x67, 0x2d, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x2d, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x2d, 0x52, 0x65, 0x71, 0x0d, 0x0a, 0x42, 0x72, 0x69, 0x64, 0x67, 0x65, 0x73, 0x3a, 0x20, 0x54, 0x52, 0x55, 0x44, 0x50, 0x76, 0x31, 0x20, 0x54, 0x43, 0x50, 0x76, 0x31, 0x20, 0x53, 0x42, 0x42, 0x72, 0x69, 0x64, 0x67, 0x65, 0x20, 0x54, 0x55, 0x52, 0x4e, 0x76, 0x31, 0x0d, 0x0a, 0x48, 0x61, 0x73, 0x68, 0x65, 0x64, 0x2d, 0x4e, 0x6f, 0x6e, 0x63, 0x65, 0x3a, 0x20, 0x7b, 0x42, 0x46, 0x33, 0x30, 0x46, 0x42, 0x45, 0x37, 0x2d, 0x32, 0x39, 0x34, 0x31, 0x2d, 0x43, 0x38, 0x32, 0x45, 0x2d, 0x33, 0x35, 0x39, 0x30, 0x2d, 0x35, 0x37, 0x33, 0x31, 0x43, 0x38, 0x32, 0x34, 0x42, 0x42, 0x45, 0x46, 0x7d, 0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x00, 0x00, 0x00];

        let msg_as_str = unsafe {from_utf8_unchecked(&msg_command)}.to_owned();
        info!("MSG command: {}", &msg_as_str);

        let commands = MSNPCommandParser::parse_message(&msg_as_str);
        let command = commands.get(0).unwrap();
        info!("MSG command payload: {}", command.payload.as_str());

        let msg = MsgPayload::from_str(command.payload.as_str()).unwrap();
        info!("msg payload payload: {}", msg.body.as_str());
        let p2p_transport_packet = P2PTransportPacket::from_str(msg.body.as_str()).unwrap();
        let p2p_transport_packet_serialized = p2p_transport_packet.to_string();

        info!("msg payload payload serialize test: {}", &p2p_transport_packet_serialized);

        assert_eq!(msg.body.as_bytes(), p2p_transport_packet_serialized.as_bytes());
        
        
        
        let original_p2p_payload = &p2p_transport_packet.payload.unwrap();
        let p2p_payload_serialized = original_p2p_payload.to_string();
        let p2p_payload_deserialized = P2PPayload::deserialize(p2p_payload_serialized.as_bytes(), p2p_transport_packet.payload_length).unwrap();

        assert_eq!(p2p_payload_deserialized.header_length, original_p2p_payload.header_length);
        assert_eq!(p2p_payload_deserialized.tf_combination, original_p2p_payload.tf_combination);

        let slp_payload = original_p2p_payload.get_payload_as_slp().unwrap();

        info!("slp payload: {}", slp_payload);
    }

    #[test]
    fn test_deserialize_msg_command_containing_no_p2p_payload() {
        env_logger::init_from_env(env_logger::Env::new().default_filter_or("info"));

        let msg_command : [u8;225] = [ 0x4d, 0x53, 0x47, 0x20, 0x36, 0x34, 0x20, 0x44, 0x20, 0x32, 0x31, 0x31, 0x0d, 0x0a, 0x4d, 0x49, 0x4d, 0x45, 0x2d, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x3a, 0x20, 0x31, 0x2e, 0x30, 0x0d, 0x0a, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x54, 0x79, 0x70, 0x65, 0x3a, 0x20, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x78, 0x2d, 0x6d, 0x73, 0x6e, 0x6d, 0x73, 0x67, 0x72, 0x70, 0x32, 0x70, 0x0d, 0x0a, 0x50, 0x32, 0x50, 0x2d, 0x44, 0x65, 0x73, 0x74, 0x3a, 0x20, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x33, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x3b, 0x7b, 0x37, 0x37, 0x63, 0x34, 0x36, 0x61, 0x38, 0x66, 0x2d, 0x33, 0x33, 0x61, 0x33, 0x2d, 0x35, 0x32, 0x38, 0x32, 0x2d, 0x39, 0x61, 0x35, 0x64, 0x2d, 0x39, 0x30, 0x35, 0x65, 0x63, 0x64, 0x33, 0x65, 0x62, 0x30, 0x36, 0x39, 0x7d, 0x0d, 0x0a, 0x50, 0x32, 0x50, 0x2d, 0x53, 0x72, 0x63, 0x3a, 0x20, 0x61, 0x65, 0x6f, 0x6e, 0x74, 0x65, 0x73, 0x74, 0x40, 0x73, 0x68, 0x6c, 0x2e, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x3b, 0x7b, 0x66, 0x35, 0x32, 0x39, 0x37, 0x33, 0x62, 0x36, 0x2d, 0x63, 0x39, 0x32, 0x36, 0x2d, 0x34, 0x62, 0x61, 0x64, 0x2d, 0x39, 0x62, 0x61, 0x38, 0x2d, 0x37, 0x63, 0x31, 0x65, 0x38, 0x34, 0x30, 0x65, 0x34, 0x61, 0x62, 0x30, 0x7d, 0x0d, 0x0a, 0x0d, 0x0a, 0x08, 0x02, 0x00, 0x00, 0xe0, 0x93, 0xf1, 0x0b, 0x00, 0x00, 0x00, 0x00];

        let msg_as_str = unsafe {from_utf8_unchecked(&msg_command)}.to_owned();
        info!("MSG command: {}", &msg_as_str);

        let commands = MSNPCommandParser::parse_message(&msg_as_str);
        let command = commands.get(0).unwrap();
        info!("MSG command payload: {}", command.payload.as_str());

        let msg = MsgPayload::from_str(command.payload.as_str()).unwrap();
        info!("msg payload payload: {}", msg.body.as_str());
        let p2p_transport_packet = P2PTransportPacket::from_str(msg.body.as_str()).unwrap();
        let p2p_transport_packet_serialized = p2p_transport_packet.to_string();

        info!("msg payload payload serialize test: {}", &p2p_transport_packet_serialized);

        assert_eq!(msg.body.as_bytes(), p2p_transport_packet_serialized.as_bytes());
    }


    #[test]
    fn test_serialize_slp_payload_200_ok() {

        let mut invite_slp_payload = SlpPayload::new();
        invite_slp_payload.first_line = String::from("INVITE MSNMSGR:aeontest3@shl.local;{77c46a8f-33a3-5282-9a5d-905ecd3eb069} MSNSLP/1.0");

        invite_slp_payload.add_header(String::from("Max-Forwards"), String::from("0"));
        invite_slp_payload.add_header(String::from("Content-Type"), String::from("application/x-msnmsgr-transreqbody"));
        invite_slp_payload.add_header(String::from("To"), String::from("<msnmsgr:aeontest3@shl.local;{77c46a8f-33a3-5282-9a5d-905ecd3eb069}>"));
        invite_slp_payload.add_header(String::from("From"), String::from("<msnmsgr:aeontest@shl.local;{f52973b6-c926-4bad-9ba8-7c1e840e4ab0}>"));
        invite_slp_payload.add_header(String::from("Via"), String::from("MSNSLP/1.0/TLP ;branch={D764D298-37B8-4C8A-B9D6-E811AED1C981}"));
        invite_slp_payload.add_header(String::from("CSeq"), String::from("0"));
        invite_slp_payload.add_header(String::from("Call-ID"), String::from("{02BB9EA5-F0DB-41BF-80E3-291CB98F9793}"));

        invite_slp_payload.add_body_property(String::from("NetID"), String::from("1040296128"));
        invite_slp_payload.add_body_property(String::from("Conn-Type"), String::from("Firewall"));
        invite_slp_payload.add_body_property(String::from("TCP-Conn-Type"), String::from("Firewall"));
        invite_slp_payload.add_body_property(String::from("UPnPNat"), String::from("false"));
        invite_slp_payload.add_body_property(String::from("ICF"), String::from("false"));
        invite_slp_payload.add_body_property(String::from("Capabilities-Flags"), String::from("1"));
        invite_slp_payload.add_body_property(String::from("Nat-Trav-Msg-Type"), String::from("WLX-Nat-Trav-Msg-Direct-Connect-Req"));
        invite_slp_payload.add_body_property(String::from("Bridges"), String::from("TRUDPv1 TCPv1 SBBridge TURNv1"));
        invite_slp_payload.add_body_property(String::from("Hashed-Nonce"), String::from("{BF30FBE7-2941-C82E-3590-5731C824BBEF}"));

        let result = SlpPayloadFactory::get_200_ok(&invite_slp_payload);

        assert_eq!(result.first_line, String::from("MSNSLP/1.0 200 OK"));
        assert_eq!(result.get_header(&String::from("CSeq")).unwrap(), &String::from("1"));
        assert_eq!(result.get_header(&String::from("To")).unwrap(), &String::from("<msnmsgr:aeontest@shl.local;{f52973b6-c926-4bad-9ba8-7c1e840e4ab0}>"));
        assert_eq!(result.get_header(&String::from("From")).unwrap(), &String::from("<msnmsgr:aeontest3@shl.local;{77c46a8f-33a3-5282-9a5d-905ecd3eb069}>"));
        assert_eq!(result.get_body_property(&String::from("Bridge")).unwrap(), &String::from("SBBridge"));

    }
}